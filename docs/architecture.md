# Architecture

*Generated by BMAD Decision Architecture Workflow v1.0*  
*Date: 2025-11-22*  
*For: delphijc*  
*Project: Network Traffic Parser*

---

## Executive Summary

Network Traffic Parser uses a **Client-Server architecture**. While originally planned as a hybrid with a browser-only mode, performance requirements for large PCAP files necessitate a server-side parsing component. The system consists of: (1) **Frontend**: React/TypeScript web interface for visualization and analysis, and (2) **Backend**: Node.js/TypeScript server for heavy lifting (PCAP parsing) and future live capture capabilities.

---

## Project Initialization

### Frontend (Browser UI)

**Initialization Command:**
```bash
npm create vite@latest client -- --template react-ts
cd client
npm install
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
npm install -D @shadcn/ui
```

### Server (Backend)

**Initialization Command:**
```bash
mkdir server && cd server
npm init -y
npm install express cors multer ws pcap-parser
npm install -D typescript @types/node @types/express @types/cors @types/multer @types/ws ts-node nodemon
npx tsc --init
```

### Monorepo Structure

```
net-pack-parser/
├── client/              # Vite + React + TypeScript browser UI
├── server/              # Node.js + TypeScript capture agent
├── shared/              # Shared TypeScript types and interfaces
├── package.json         # Root package.json for workspace management
└── README.md
```

---

## Decision Summary

| Category | Decision | Version | Affects Epics | Rationale |
| -------- | -------- | ------- | ------------- | --------- |
| **Frontend Framework** | React | 19.x | Epic 1-6 (All browser features) | Industry standard, excellent TypeScript support, large ecosystem, hooks for state management |
| **Build Tool** | Vite | 7.2.4 | Epic 1-6 | Fast HMR, optimized production builds, superior DX compared to CRA, native ESM |
| **Language** | TypeScript | ~5.9.3 | Epic 1-8 (All epics) | Type safety, better IDE support, catches errors at compile time, self-documenting code |
| **CSS Framework** | Tailwind CSS | 3.x (stable) | Epic 1-6 | Utility-first, rapid UI development, consistent design system, excellent with React |
| **Component Library** | shadcn/ui | Latest | Epic 1-6 | Accessible, customizable, Radix UI primitives, copy-paste components (not npm dependency) |
| **Server Runtime** | Node.js | 22.x LTS | Epic 7-8 | LTS support, excellent async I/O for WebSocket streaming, mature ecosystem |
| **Server Framework** | Express.js | 4.x | Epic 7-8 | Lightweight, minimal, flexible middleware system, widely adopted |
| **WebSocket Library** | ws | 8.x | Epic 8 | Native WebSocket for Node.js, low-level control, high performance, TypeScript types available |
| **Project Structure** | Monorepo | N/A | All epics | Frontend + Server in same repo for shared types, easier development, single version control |
| **State Management - Server State** | TanStack Query | 5.x | Epic 1-8 | Best-in-class async state management, automatic caching/refetching, perfect for API calls and WebSocket data |
| **State Management - UI State** | Zustand | 4.x | Epic 1-6 | Lightweight (3KB), minimal boilerplate, fast, no Provider wrapper needed, simple API |
| **PCAP Parser (Backend)** | pcap-parser | Latest | Epic 1.5 | Node.js based parsing to handle large files efficiently without blocking the browser thread. |
| **Packet Capture (Server)** | cap | 0.2.x | Epic 7-8 | Cross-platform libpcap bindings (Linux/macOS/Windows), simpler API, stable despite age |
| **Chart Library** | Recharts | 2.x | Epic 6 | React-native, TypeScript support, modern declarative API, composable charts, responsive |
| **Testing Framework** | Vitest | 1.x | Epic 1-8 | Fast Vite-powered unit tests, compatible with Vitest ecosystem, better DX than Jest |
| **Component Testing** | React Testing Library | 14.x | Epic 1-6 | User-centric testing approach, excellent with TypeScript, industry standard |
| **YARA Engine** | yara-js | Latest | Epic 3 | WebAssembly YARA port, browser-compatible, actively maintained, full YARA syntax support |
| **API Response Format** | Direct HTTP Status | N/A | Epic 7-8 | RESTful standard, simpler than wrapped responses, uses HTTP semantics correctly |

**Provided by Vite React TypeScript Starter:**
- ✅ React 19 with TypeScript strict mode
- ✅ Vite build system with HMR
- ✅ ESLint configuration
- ✅ Basic project structure (`src/`, `public/`)
- ✅ TypeScript configuration (`tsconfig.json`)

**All Decisions Finalized:**
- ✅ State management: TanStack Query (server state) + Zustand (UI state)
- ✅ PCAP parsing: pcap-decoder (browser)
- ✅ Packet capture: cap library (server, libpcap bindings)
- ✅ Charts: Recharts
- ✅ Testing: Vitest + React Testing Library
- ✅ API format: Direct responses with HTTP status codes
- ✅ YARA: yara-js (WebAssembly)
- ✅ Database: localStorage → IndexedDB (browser), file system (server), PostgreSQL (future)


---

## Project Structure

```
net-pack-parser/
├── client/                          # Browser UI (Vite + React + TypeScript)
│   ├── public/                      # Static assets
│   ├── src/
│   │   ├── components/              # Reusable UI components (shadcn/ui + custom)
│   │   │   ├── ui/                  # shadcn/ui components (Button, Card, Table, etc.)
│   │   │   ├── PacketList.tsx
│   │   │   ├── PacketDetailView.tsx
│   │   │   ├── FilterBar.tsx
│   │   │   ├── ThreatPanel.tsx
│   │   │   └── PerformanceDashboard.tsx
│   │   ├── pages/                   # Route-level page components
│   │   │   ├── HomePage.tsx
│   │   │   ├── PCAPAnalysisPage.tsx
│   │   │   ├── LiveCapturePage.tsx
│   │   │   └── SettingsPage.tsx
│   │   ├── hooks/                   # Custom React hooks
│   │   │   ├── useLocalStorage.ts
│   │   │   ├── usePCAPParser.ts
│   │   │   ├── useWebSocket.ts
│   │   │   └── useThreatDetection.ts
│   │   ├── services/                # API clients and external services
│   │   │   ├── captureAgentApi.ts   # REST API client for server
│   │   │   ├── webSocketClient.ts   # WebSocket client for packet streaming
│   │   │   └── localStorage.ts      # LocalStorage wrapper
│   │   ├── utils/                   # Utility functions
│   │   │   ├── pcapParser.ts        # PCAP file parsing logic
│   │   │   ├── threatDetection.ts   # Threat detection algorithms
│   │   │   ├── bpfFilter.ts         # BPF filter engine
│   │   │   ├── hashGenerator.ts     # SHA-256, MD5 hashing
│   │   │   └── formatters.ts        # Data formatting utilities
│   │   ├── types/                   # TypeScript types/interfaces
│   │   │   ├── packet.ts
│   │   │   ├── threat.ts
│   │   │   └── captureSession.ts
│   │   ├── store/                   # State management (TBD: Redux/Zustand/TanStack Query)
│   │   ├── constants/               # Constants and configuration
│   │   ├── App.tsx                  # Root component
│   │   ├── main.tsx                 # Entry point
│   │   └── index.css                # Global styles + Tailwind directives
│   ├── package.json
│   ├── tsconfig.json
│   ├── vite.config.ts
│   └── tailwind.config.js
│
├── server/                          # Capture Agent (Node.js + TypeScript)
│   ├── src/
│   │   ├── index.ts                 # Entry point, Express app setup
│   │   ├── routes/                  # API route handlers
│   │   │   ├── auth.ts              # POST /api/auth/login
│   │   │   ├── interfaces.ts        # GET /api/interfaces
│   │   │   ├── capture.ts           # POST /api/capture/start, /stop
│   │   │   └── sessions.ts          # GET /api/capture/sessions, download
│   │   ├── services/                # Business logic
│   │   │   ├── captureService.ts    # Packet capture via libpcap
│   │   │   ├── authService.ts       # JWT generation/validation
│   │   │   └── sessionManager.ts    # Capture session storage
│   │   ├── websocket/               # WebSocket server
│   │   │   └── packetStream.ts      # Real-time packet streaming
│   │   ├── middleware/              # Express middleware
│   │   │   ├── auth.ts              # JWT verification
│   │   │   └── errorHandler.ts      # Error handling
│   │   ├── types/                   # TypeScript types
│   │   │   └── capture.ts
│   │   ├── config/                  # Configuration
│   │   │   └── index.ts             # Load from .env
│   │   └── utils/                   # Utilities
│   ├── package.json
│   ├── tsconfig.json
│   └── .env.example
│
├── shared/                          # Shared TypeScript types between client & server
│   ├── types/
│   │   ├── packet.ts                # Packet interface
│   │   ├── session.ts               # Capture session interface
│   │   └── auth.ts                  # Auth payloads
│   └── package.json
│
├── docs/                            # Project documentation
│   ├── prd.md
│   ├── epics.md
│   ├── architecture.md              # This file
│   └── bmm-workflow-status.yaml
│
├── .github/                         # GitHub Actions CI/CD
├── package.json                     # Root workspace package.json
└── README.md
```

---

## Epic to Architecture Mapping

| Epic | Architecture Components | Notes |
| ---- | ----------------------- | ----- |
| **Epic 1: Foundation & Browser-Only** | `client/src/utils/pcapParser.ts`, `client/src/services/localStorage.ts`, `client/src/components/PacketList.tsx`, `client/src/utils/hashGenerator.ts` | Browser-only mode, no server dependency, localStorage for data |
| **Epic 2: Search, Filter & Analysis** | `client/src/utils/bpfFilter.ts`, `client/src/components/FilterBar.tsx`, search logic in `PacketList.tsx` | BPF filter engine, multi-criteria search, all client-side |
| **Epic 3: Threat Detection & Security** | `client/src/utils/threatDetection.ts`, `client/src/components/ThreatPanel.tsx`, YARA engine (WebAssembly) | SQL injection, XSS, command injection detection, MITRE ATT&CK mapping |
| **Epic 4: Performance Monitoring** | `client/src/components/PerformanceDashboard.tsx`, `client/src/hooks/usePerformanceObserver.ts` | Core Web Vitals via Performance Observer API, browser-native |
| **Epic 5: Forensic Investigation** | `client/src/utils/chainOfCustody.ts`, `client/src/components/TimelineView.tsx`, hash verification | Timeline reconstruction, evidence management, SHA-256/MD5 hashing |
| **Epic 6: Visualization & Reporting** | `client/src/components/Charts/`, export utilities in `client/src/utils/`, Chart.js or Recharts | Protocol distribution charts, export CSV/JSON/PCAP |
| **Epic 7: Server Capture Agent** | `server/src/services/captureService.ts`, `server/src/routes/auth.ts`, `server/src/routes/capture.ts`, `server/src/services/sessionManager.ts` | Node.js server with Express, JWT auth, libpcap bindings, session storage |
| **Epic 8: Real-Time Streaming** | `server/src/websocket/packetStream.ts`, `client/src/services/webSocketClient.ts`, `client/src/hooks/useWebSocket.ts` | WebSocket (ws library), <500ms latency requirement, real-time threat detection on streamed packets |

---

## Technology Stack Details

### Core Technologies

#### Frontend (Browser UI)

**Runtime & Framework:**
- **React 19.x** - UI framework with hooks, concurrent features, Actions API
- **TypeScript ~5.9.3** - Type-safe JavaScript with strict mode enabled
- **Vite 7.2.4** - Build tool with fast HMR and optimized production bundles

**Styling:**
- **Tailwind CSS 3.x** - Utility-first CSS framework
- **shadcn/ui** - Accessible component library built on Radix UI primitives
- **Deep Dive Color Theme** - Deep Blue (#2563EB), Teal (#14B8A6) as per UX Design

**State Management:**
- **TanStack Query 5.x** - Server state management (API calls, WebSocket data, caching)
- **Zustand 4.x** - UI state management (filters, selections, preferences)

**Key Libraries:**
- **PCAP Parsing:** pcap-decoder (TypeScript, browser-native, Web Streams API)
- **Hashing:** Web Crypto API (native, SHA-256/MD5)
- **BPF Filtering:** Custom implementation (JavaScript BPF parser)
- **YARA Engine:** yara-js (WebAssembly YARA port)
- **Charts:** Recharts 2.x (React-native, TypeScript, composable)
- **Testing:** Vitest 1.x + React Testing Library 14.x

#### Server (Capture Agent)

**Runtime & Framework:**
- **Node.js 22.x LTS** - JavaScript runtime with async I/O
- **TypeScript 5.7.x** - Type safety on server-side
- **Express.js 4.x** - Web framework for REST API

**WebSocket:**
- **ws 8.x** - Fast, lightweight WebSocket library

**Packet Capture:**
- **cap 0.2.x** - Cross-platform libpcap/WinPcap bindings for Linux, macOS, Windows
- **Note:** Library is older (2018) but stable; tested with Node.js 22 LTS

**Authentication & Security:**
- **jsonwebtoken** - JWT token generation/validation
- **bcrypt** - Password hashing (Argon2 alternative considered)
- **TLS 1.3** - WebSocket Secure (WSS) encryption

**Storage:**
- **File System** - PCAP session files stored on disk (default: `/var/lib/net-pack-parser/sessions/`)
- **Future:** PostgreSQL for session metadata, user management, audit logs

**Deployment:**
- **Docker** - Containerized deployment (recommended)
- **Systemd** - Linux service (alternative)
- **Windows Service** - Windows deployment (alternative)
- **macOS launchd** - macOS deployment (alternative)

### Integration Points

#### WebSocket Communication

**Protocol:** WSS (WebSocket Secure) over TLS 1.3

**Message Format:**
- **Control Messages:** JSON
  ```json
  {
    "type": "start_capture",
    "interface": "eth0",
    "filter": "tcp port 443",
    "bufferLimit": 10000
  }
  ```
- **Data Messages:** Binary packet data (compressed with gzip or brotli)
  ```json
  {
    "type": "packet",
    "timestamp": 1700000000000,
    "data": <binary ArrayBuffer>
  }
  ```

**Heartbeat:** Keep-alive ping every 30 seconds  
**Reconnection:** Exponential backoff (1s, 2s, 4s, 8s, max 32s)

#### REST API

**Base URL:** `https://capture-agent-host:port/api`

**Endpoints:**
- `POST /api/auth/login` - Authenticate (username/password or API key) → JWT token
- `GET /api/interfaces` - List available network interfaces (requires JWT)
- `POST /api/capture/start` - Start packet capture session (requires JWT)
- `POST /api/capture/stop` - Stop packet capture session (requires JWT)
- `GET /api/capture/sessions` - List stored capture sessions (requires JWT)
- `GET /api/capture/download/:id` - Download PCAP file (requires JWT)

**Authentication:** Bearer token in `Authorization` header
```
Authorization: Bearer <JWT_TOKEN>
```

**Response Format:** Direct responses using HTTP status codes
- **Success (200-299):** Return data directly in response body
  ```json
  {
    "sessionId": "session-abc-123",
    "started": true,
    "interface": "eth0"
  }
  ```
- **Error (400-599):** Return error object with HTTP status code
  ```json
  {
    "error": {
      "message": "Interface not found",
      "code": "INTERFACE_NOT_FOUND"
    }
  }
  ```

---

## Implementation Patterns

### Naming Conventions

**Frontend (React/TypeScript):**
- **Components:** PascalCase (`PacketList.tsx`, `ThreatPanel.tsx`)
- **Hooks:** camelCase with `use` prefix (`useLocalStorage.ts`, `usePCAPParser.ts`)
- **Utilities:** camelCase (`bpfFilter.ts`, `hashGenerator.ts`)
- **Types/Interfaces:** PascalCase (`Packet`, `ThreatAlert`, `CaptureSession`)
- **Constants:** UPPER_SNAKE_CASE (`MAX_PACKET_SIZE`, `DEFAULT_BUFFER_LIMIT`)

**Server (Node.js/TypeScript):**
- **Files:** camelCase (`captureService.ts`, `authService.ts`)
- **Classes:** PascalCase (`CaptureService`, `SessionManager`)
- **Functions:** camelCase (`startCapture()`, `generateToken()`)
- **API Routes:** kebab-case (`/api/capture/start`, `/api/capture/sessions`)

**Database/Storage:**
- **Table Names:** snake_case, plural (`capture_sessions`, `threat_alerts`)
- **Column Names:** snake_case (`session_id`, `created_at`, `packet_count`)
- **Foreign Keys:** table_id format (`session_id`, `user_id`)

### Code Organization

**Component Structure:**
```tsx
// PacketList.tsx
import { useState, useEffect } from 'react';
import { Packet } from '@/types/packet';
import { Button } from '@/components/ui/button';

interface PacketListProps {
  packets: Packet[];
  onPacketSelect: (packet: Packet) => void;
}

export function PacketList({ packets, onPacketSelect }: PacketListProps) {
  // Component logic
}
```

**Test Co-location:**
```
components/
├── PacketList.tsx
├── PacketList.test.tsx            # Test file co-located with component
└── __tests__/                     # Alternative: tests in __tests__ folder
```

**Absolute Imports:**
- Use `@/` alias for `src/` directory
- Configure in `tsconfig.json` and `vite.config.ts`:
  ```json
  {
    "compilerOptions": {
      "baseUrl": ".",
      "paths": {
        "@/*": ["src/*"]
      }
    }
  }
  ```

### Error Handling

**Frontend:**
```typescript
// Consistent error handling pattern
try {
  const result = await parsePCAP(file);
  // Handle success
} catch (error) {
  if (error instanceof PCAPParseError) {
    showNotification({
      type: 'error',
      message: `Failed to parse PCAP: ${error.message}`,
    });
  } else {
    showNotification({
      type: 'error',
      message: 'An unexpected error occurred',
    });
    console.error('Unexpected error:', error);
  }
}
```

**Server:**
```typescript
// Express error middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  logger.error('Server error:', err);
  res.status(err.statusCode || 500).json({
    error: {
      message: err.message,
      code: err.code || 'INTERNAL_ERROR',
    },
  });
});
```

**Error Response Format (TBD - needs decision):**
```json
{
  "error": {
    "message": "Human-readable error message",
    "code": "ERROR_CODE",
    "details": { ... }
  }
}
```

### Logging Strategy

**Frontend (Browser Console):**
- Development: Verbose logging with `console.log`, `console.warn`, `console.error`
- Production: Error logging only, consider integration with Sentry or LogRocket
- Pattern:
  ```typescript
  const logger = {
    debug: (...args) => __DEV__ && console.log('[DEBUG]', ...args),
    info: (...args) => console.info('[INFO]', ...args),
    warn: (...args) => console.warn('[WARN]', ...args),
    error: (...args) => console.error('[ERROR]', ...args),
  };
  ```

**Server (Structured Logging):**
- Use `winston` or `pino` for structured JSON logs
- Log levels: `error`, `warn`, `info`, `debug`
- Include: timestamp, level, message, context (user_id, session_id)
- Pattern:
  ```typescript
  logger.info('Capture started', {
    userId: req.user.id,
    interface: 'eth0',
    filter: 'tcp port 443',
  });
  ```

---

## Data Architecture

### Browser Storage (Browser-Only Mode)

**localStorage:**
- **Capacity:** 5-10MB typical browser limit
- **Data:**
  - User settings/preferences
  - Saved BPF filters
  - Capture agent connection profiles
  - Performance monitoring data (last 24 hours)
  
**IndexedDB:**
- **Capacity:** Much larger (~50MB+ varies by browser)
- **Data:**
  - Parsed packet metadata (timestamp, IPs, ports, protocol, size)
  - Extracted files from network traffic
  - Threat detection results
  - Chain of custody logs
  
**Data Models (TBD - needs detailed schema):**

```typescript
// Packet interface (shared between client and server)
interface Packet {
  id: string;                    // UUID
  timestamp: number;             // Unix timestamp (ms)
  sourceIP: string;              // IPv4 or IPv6
  destIP: string;
  sourcePort: number;
  destPort: number;
  protocol: string;              // 'TCP', 'UDP', 'ICMP', 'HTTP', 'HTTPS', 'DNS'
  length: number;                // Bytes
  rawData: ArrayBuffer;          // Packet payload
  flags?: string[];              // TCP flags ['SYN', 'ACK']
  sessionId?: string;            // For TCP session grouping
}

interface ThreatAlert {
  id: string;
  packetId: string;              // Reference to Packet.id
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  type: 'sql_injection' | 'xss' | 'command_injection' | 'directory_traversal' | 'sensitive_data';
  description: string;
  mitreAttack: string[];         // ['T1190', 'T1059']
  timestamp: number;
  falsePositive: boolean;
  confirmed: boolean;
}

interface CaptureSession {
  id: string;
  name: string;
  startTime: number;
  endTime?: number;
  packetCount: number;
  fileSizeBytes: number;
  sha256: string;
  md5: string;
  interface?: string;            // Network interface (if from server)
  filter?: string;               // BPF filter applied
  serverUrl?: string;            // Capture agent URL (if connected mode)
}
```

### Server Storage (Connected Mode)

**File System:**
- **PCAP Files:** `/var/lib/net-pack-parser/sessions/`
- **Format:** `session-{uuid}.pcap`
- **Retention:** Configurable (default 30 days)

**Future: PostgreSQL Database**
- **Tables:**
  - `users` - Authentication
  - `capture_sessions` - Session metadata
  - `api_keys` - API key management
  - `audit_log` - Access control audit trail

---

## API Contracts

### REST API Request/Response Examples

**Authentication:**
```http
POST /api/auth/login
Content-Type: application/json

{
  "username": "analyst",
  "password": "securepassword"
}
```

Response:
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 3600,
  "user": {
    "id": "user-123",
    "username": "analyst"
  }
}
```

**List Network Interfaces:**
```http
GET /api/interfaces
Authorization: Bearer {JWT_TOKEN}
```

Response:
```json
{
  "interfaces": [
    {
      "name": "eth0",
      "description": "Ethernet Interface",
      "addresses": ["192.168.1.100"]
    },
    {
      "name": "wlan0",
      "description": "Wireless Interface",
      "addresses": ["10.0.0.50"]
    }
  ]
}
```

**Start Capture:**
```http
POST /api/capture/start
Authorization: Bearer {JWT_TOKEN}
Content-Type: application/json

{
  "interface": "eth0",
  "filter": "tcp port 443",
  "bufferLimit": 10000
}
```

Response:
```json
{
  "sessionId": "session-abc-123",
  "started": true,
  "interface": "eth0",
  "filter": "tcp port 443"
}
```

---

## Security Architecture

### Browser Security (All Modes)

- **Content Security Policy (CSP):** Prevent XSS via strict CSP headers
- **Input Sanitization:** All user inputs sanitized before rendering
- **Crypto API:** Use native Web Crypto for SHA-256/MD5 hashing
- **No Third-Party Tracking:** Privacy-first, no analytics or tracking scripts
- **localStorage Scoping:** Data scoped per-origin

### Server Security (Connected Mode)

- **TLS 1.3:** All WebSocket and HTTPS communication encrypted
- **JWT Authentication:** Tokens expire after 1 hour, refresh token strategy (TBD)
- **Password Hashing:** bcrypt with cost factor 12 (or Argon2)
- **API Keys:** 256-bit cryptographically random keys
- **IP ACLs:** Optional IP-based access control lists
- **Least Privilege:** Capture agent runs with minimum required privileges
  - Linux: Use `CAP_NET_RAW` capability instead of root
  - Windows: Run with limited service account
- **TLS Client Certificates:** Optional mutual TLS authentication
- **Rate Limiting:** Prevent brute-force attacks (TBD: library selection)

---

## Performance Considerations

### Frontend Performance

- **PCAP Parsing:** Use Web Workers to avoid blocking main thread
- **Virtual Scrolling:** For large packet lists (react-window or react-virtuoso)
- **Lazy Loading:** Code-split routes and heavy components
- **Memoization:** Use `React.memo`, `useMemo`, `useCallback` for expensive computations
- **Debouncing:** Filter/search inputs debounced to 300ms
- **Bundle Size:** Target <2MB total bundle size (as per NFR-P6)

### Server Performance

- **Packet Buffering:** Ring buffer for captured packets, configurable limit
- **Stream Compression:** Gzip or Brotli compression for WebSocket packets
- **Connection Pooling:** Reuse WebSocket connections
- **Memory Management:** Monitor memory, prevent leaks with buffer limits
- **Concurrency:** Handle 5+ concurrent client connections (as per NFR-SP7)

---

## Deployment Architecture

### Browser-Only Mode

**Deployment Options:**
- **Static Hosting:** GitHub Pages, Netlify, Vercel, AWS S3 + CloudFront
- **CDN Distribution:** Global edge caching for fast load times
- **Zero Backend Cost:** Completely free hosting option

**Build Command:**
```bash
cd client
npm run build
# Output: dist/ folder ready for static hosting
```

### Connected Mode

**Capture Agent Deployment:**

**Option 1: Docker (Recommended)**
```dockerfile
FROM node:22-alpine
RUN apk add --no-cache libpcap-dev
WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY . .
CMD ["node", "dist/index.js"]
```

**Option 2: Systemd (Linux)**
```ini
[Unit]
Description=Network Traffic Parser Capture Agent
After=network.target

[Service]
Type=simple
User=ntp-agent
WorkingDirectory=/opt/net-pack-parser
ExecStart=/usr/bin/node dist/index.js
Restart=on-failure
Environment="NODE_ENV=production"
CapabilityBoundingSet=CAP_NET_RAW CAP_NET_ADMIN
AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN

[Install]
WantedBy=multi-user.target
```

**Option 3: Windows Service** (TBD: node-windows or similar)

**Infrastructure:**
- **Development:** Docker Compose for local dev (UI + Agent)
- **Production:** Kubernetes for enterprise, Docker for SMB
- **Monitoring:** Prometheus + Grafana for agent metrics (TBD)

---

## Development Environment

### Prerequisites

**Required:**
- Node.js 22.x LTS
- npm 10.x or pnpm 9.x
- Git
- Modern browser (Chrome 90+, Firefox 88+, Safari 14+)

**For Server Development:**
- libpcap (Linux/macOS) or WinPcap/Npcap (Windows)
- Docker (optional, for containerized testing)

**For Frontend Development:**
- VS Code (recommended) with extensions:
  - ESLint
  - Prettier
  - TypeScript
  - Tailwind CSS IntelliSense

### Setup Commands

**Clone Repository:**
```bash
git clone https://github.com/delphijc/net-pack-parser.git
cd net-pack-parser
```

**Install Dependencies (Monorepo):**
```bash
npm install              # Install root workspace dependencies
cd client && npm install # Install frontend dependencies
cd ../server && npm install # Install server dependencies
```

**Frontend Development:**
```bash
cd client
npm run dev              # Start Vite dev server on http://localhost:5173
```

**Server Development:**
```bash
cd server
npm run dev              # Start server with nodemon on http://localhost:3000
```

**Run Tests:**
```bash
cd client
npm test                 # Vitest unit tests

cd ../server
npm test                 # Server tests
```

---

## Architecture Decision Records (ADRs)

### ADR-001: Monorepo vs Multi-Repo

**Decision:** Monorepo structure  
**Rationale:** Shared TypeScript types between frontend and server, easier development workflow, single version control, atomic commits across frontend/backend  
**Alternatives Considered:** Separate repositories (rejected due to type duplication and sync complexity)  
**Date:** 2025-11-22

### ADR-002: Vite vs Create React App vs Next.js

**Decision:** Vite for frontend build tool  
**Rationale:** Fast HMR, native ESM, optimized builds, better DX, CRA is deprecated. Next.js overkill for SPA with optional server.  
**Alternatives Considered:** CRA (deprecated), Next.js (too heavyweight), Parcel (less ecosystem)  
**Date:** 2025-11-22

### ADR-003: ws vs Socket.IO for WebSocket

**Decision:** ws library for server WebSocket  
**Rationale:** Low-level control, high performance, TypeScript support, no unnecessary abstractions. Socket.IO adds complexity we don't need (no rooms, no fallback to polling needed).  
**Alternatives Considered:** Socket.IO (too heavyweight), native Node.js WebSocket (too new, limited browser support)  
**Date:** 2025-11-22

### ADR-004: Browser-Only Mode for Privacy

**Decision:** Support browser-only mode with zero server dependency  
**Rationale:** Privacy-first architecture, users can analyze sensitive PCAP files without uploading to any server. Enables free static hosting. Differentiates from cloud-only competitors.  
**Tradeoffs:** Cannot perform live packet capture in browser-only mode, limited to analyzing pre-captured PCAP files  
**Date:** 2025-11-22

### ADR-005: Hybrid Architecture (Browser + Optional Server)

**Decision:** Hybrid architecture with two deployment modes  
**Rationale:** Maximum flexibility - users choose privacy (browser-only) or live capture (connected mode). Single codebase supports both use cases.  
**Complexity:** Requires careful design to support both modes, conditional features based on server connection  
**Date:** 2025-11-22

### ADR-006: State Management - TanStack Query + Zustand Hybrid

**Decision:** TanStack Query for server state + Zustand for UI state  
**Rationale:** Best of both worlds approach - TanStack Query excels at API data fetching, caching, and synchronization (perfect for capture agent API and WebSocket data), while Zustand provides a lightweight (3KB), zero-boilerplate solution for local UI state (filters, selections, theme). This hybrid approach avoids Redux's complexity while providing better separation of concerns than relying solely on React Context or a single state library.  
**Alternatives Considered:** Redux Toolkit + RTK Query (rejected due to boilerplate), Zustand alone (rejected, doesn't handle async server state as well)  
**Date:** 2025-11-22

### ADR-007: PCAP Parser - pcap-decoder

**Decision:** pcap-decoder for browser-based PCAP parsing  
**Rationale:** Only actively maintained (2024) JavaScript PCAP parser with TypeScript support, browser-native `ArrayBuffer`/`Uint8Array` handling, and Web Streams API support for large files. Alternatives like `pcap-parser` haven't been updated since 2018.  
**Alternatives Considered:** pcap-parser (rejected, inactive maintenance), Kaitai Struct (rejected, overkill for PCAP only)  
**Risk:** Relatively new library, but open-source allows forking if needed  
**Date:** 2025-11-22

### ADR-008: Packet Capture - cap library

**Decision:** cap library for server-side packet capture  
**Rationale:** Cross-platform libpcap/WinPcap bindings supporting Linux, macOS, and Windows. While the library hasn't been updated since 2018, it's stable and well-tested. Both alternatives (node-libpcap, pcap) are similarly unmaintained (last updates 2018-2020), so we chose the one with simpler API and proven Windows support.  
**Risk Mitigation:** Thoroughly tested with Node.js 22 LTS; may require forking for future maintenance  
**Alternatives Considered:** node-libpcap/pcap (similar age, more complex API), writing custom bindings (rejected, too time-consuming)  
**Date:** 2025-11-22

### ADR-009: Testing Stack - Vitest + React Testing Library + Playwright

**Decision:** Vitest for unit tests, React Testing Library for component tests, Playwright for E2E  
**Rationale:** Vite-native testing (Vitest) provides fast HMR and compatibility with Vite build config. React Testing Library promotes user-centric testing. Playwright offers reliable cross-browser E2E testing with excellent debugging and auto-wait features.  
**Alternatives Considered:** Jest (rejected, slower with Vite), Cypress (rejected for E2E, Playwright has better TypeScript support)  
**Date:** 2025-11-22

### ADR-010: Chart Library - Recharts

**Decision:** Recharts for data visualization  
**Rationale:** React-native declarative API, excellent TypeScript support, composable chart components, responsive out-of-the-box, and simpler than D3.js for standard chart types (pie, line, bar).  
**Alternatives Considered:** Chart.js (rejected, imperative API less React-friendly), D3.js (rejected, overkill for standard charts)  
**Date:** 2025-11-22

### ADR-011: API Response Format - Direct HTTP Status Codes

**Decision:** RESTful direct responses using HTTP status codes  
**Rationale:** Simpler than wrapped responses, follows REST conventions, leverages HTTP semantics correctly. Success (2xx) returns data directly; errors (4xx/5xx) return error object with appropriate status code. Industry standard, easier for API consumers.  
**Alternatives Considered:** Wrapped format `{success, data, error}` (rejected, adds unnecessary complexity and verbosity)  
**Date:** 2025-11-22

### ADR-012: YARA Engine - yara-js

**Decision:** yara-js for YARA signature scanning  
**Rationale:** WebAssembly port of YARA, browser-compatible, actively maintained, supports full YARA syntax. Enables malware detection in browser without server dependency.  
**Alternatives Considered:** Custom YARA parser (rejected, too complex), server-side only YARA (rejected, doesn't work in browser-only mode)  
**Date:** 2025-11-22

---
