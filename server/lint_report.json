
> net-pack-parser-server@1.0.0 lint
> ESLINT_USE_FLAT_CONFIG=false eslint . --format=json

[{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/controllers/AuthController.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":40,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":63}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.AuthController = void 0;\nconst jsonwebtoken_1 = __importDefault(require('jsonwebtoken'));\nconst ADMIN_USER = process.env.ADMIN_USER || 'admin';\nconst ADMIN_PASS = process.env.ADMIN_PASS || 'password';\nconst JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-key-change-in-prod';\nclass AuthController {\n  static login(req, res) {\n    const { username, password } = req.body;\n    if (!username || !password) {\n      res.status(400).json({ error: 'Username and password are required' });\n      return;\n    }\n    if (username === ADMIN_USER && password === ADMIN_PASS) {\n      const token = jsonwebtoken_1.default.sign(\n        { username, role: 'admin' },\n        JWT_SECRET,\n        { expiresIn: '24h' },\n      );\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: 'Invalid credentials' });\n    }\n  }\n}\nexports.AuthController = AuthController;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/controllers/CaptureController.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":63},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'promiscuous' is assigned a value but never used.","line":10,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":18},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":134,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":134,"endColumn":29},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":135,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":135,"endColumn":33}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.CaptureController = void 0;\nconst CaptureService_1 = require('../services/CaptureService');\nconst StorageService_1 = require('../services/StorageService');\nclass CaptureController {\n  static async startCapture(req, res) {\n    const {\n      interface: interfaceName,\n      promiscuous,\n      filter,\n      sizeLimit,\n    } = req.body;\n    if (!interfaceName) {\n      res.status(400).json({ error: 'Interface name is required' });\n      return;\n    }\n    try {\n      const session = await CaptureService_1.CaptureService.startCapture(\n        interfaceName,\n        filter,\n        sizeLimit ? Number(sizeLimit) : 0,\n      );\n      res.status(201).json({\n        message: 'Capture started',\n        data: {\n          id: session.id,\n          output: session.outputFilePath,\n        },\n      });\n    } catch (error) {\n      console.error('Start capture error details:', error);\n      if (error.message.includes('already running')) {\n        res.status(409).json({ error: error.message });\n      } else if (\n        error.message.toLowerCase().includes('syntax') ||\n        error.message.toLowerCase().includes('expression')\n      ) {\n        res.status(400).json({ error: `Invalid BPF filter: ${error.message}` });\n      } else {\n        res.status(500).json({ error: 'Failed to start capture' });\n      }\n    }\n  }\n  static stopCapture(req, res) {\n    const { interface: interfaceName } = req.body;\n    if (!interfaceName) {\n      res.status(400).json({ error: 'Interface name is required' });\n      return;\n    }\n    try {\n      const info = CaptureService_1.CaptureService.stopCapture(interfaceName);\n      res.status(200).json({\n        message: 'Capture stopped',\n        data: info,\n      });\n    } catch (error) {\n      console.error('Stop capture error:', error);\n      if (error.message.includes('No active capture')) {\n        res.status(404).json({ error: error.message });\n      } else {\n        res.status(500).json({ error: 'Failed to stop capture' });\n      }\n    }\n  }\n  static pauseCapture(req, res) {\n    const { interface: interfaceName } = req.body;\n    if (!interfaceName) {\n      res.status(400).json({ error: 'Interface name is required' });\n      return;\n    }\n    try {\n      CaptureService_1.CaptureService.pauseCapture(interfaceName);\n      res.status(200).json({ message: 'Capture paused' });\n    } catch (error) {\n      console.error('Pause capture error:', error);\n      if (error.message.includes('No active capture')) {\n        res.status(404).json({ error: error.message });\n      } else {\n        res.status(500).json({ error: 'Failed to pause capture' });\n      }\n    }\n  }\n  static resumeCapture(req, res) {\n    const { interface: interfaceName } = req.body;\n    if (!interfaceName) {\n      res.status(400).json({ error: 'Interface name is required' });\n      return;\n    }\n    try {\n      CaptureService_1.CaptureService.resumeCapture(interfaceName);\n      res.status(200).json({ message: 'Capture resumed' });\n    } catch (error) {\n      console.error('Resume capture error:', error);\n      if (error.message.includes('No active capture')) {\n        res.status(404).json({ error: error.message });\n      } else {\n        res.status(500).json({ error: 'Failed to resume capture' });\n      }\n    }\n  }\n  static getStats(req, res) {\n    const { interface: interfaceName } = req.query;\n    if (!interfaceName || typeof interfaceName !== 'string') {\n      res\n        .status(400)\n        .json({ error: 'Interface name is required (query param: interface)' });\n      return;\n    }\n    try {\n      const stats =\n        CaptureService_1.CaptureService.getCaptureStats(interfaceName);\n      res.status(200).json(stats);\n    } catch (error) {\n      if (error.message.includes('No active capture')) {\n        res.status(404).json({ error: error.message });\n      } else {\n        console.error('Get stats error:', error);\n        res.status(500).json({ error: 'Failed to get capture stats' });\n      }\n    }\n  }\n  static downloadCapture(req, res) {\n    const { id } = req.params;\n    if (!id) {\n      res.status(400).json({ error: 'Capture ID is required' });\n      return;\n    }\n    // Basic path traversal prevention\n    if (id.includes('..') || id.includes('/') || id.includes('\\\\')) {\n      res.status(400).json({ error: 'Invalid capture ID' });\n      return;\n    }\n    const fs = require('fs');\n    const path = require('path');\n    // Allow ID to be just UUID or filename\n    let filename = id;\n    if (!filename.endsWith('.pcap')) {\n      filename += '.pcap';\n    }\n    const filePath = path.join(\n      StorageService_1.StorageService.getCaptureDir(),\n      filename,\n    );\n    if (!fs.existsSync(filePath)) {\n      res.status(404).json({ error: 'Capture file not found' });\n      return;\n    }\n    res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n    res.setHeader('Content-Type', 'application/vnd.tcpdump.pcap');\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n    fileStream.on('error', (error) => {\n      console.error('Error streaming file:', error);\n      if (!res.headersSent) {\n        res.status(500).json({ error: 'Failed to download file' });\n      }\n    });\n  }\n  static listSessions(req, res) {\n    try {\n      const sessions = CaptureService_1.CaptureService.getSessions();\n      res.json(sessions);\n    } catch (error) {\n      // Error handler should catch this ideally if logic fails, but for now manual try/catch or just let it bubble\n      // Since method is static and simple, just res.json\n      console.error('List sessions error', error);\n      res.status(500).json({ error: 'Failed to list sessions' });\n    }\n  }\n}\nexports.CaptureController = CaptureController;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/controllers/InterfaceController.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":63}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.InterfaceController = void 0;\nconst CaptureService_1 = require('../services/CaptureService');\nclass InterfaceController {\n  static listInterfaces(req, res) {\n    try {\n      const interfaces = CaptureService_1.CaptureService.getInterfaces();\n      res.json(interfaces);\n    } catch (error) {\n      console.error('InterfaceController error:', error);\n      res\n        .status(500)\n        .json({ error: 'Internal Server Error fetching interfaces' });\n    }\n  }\n}\nexports.InterfaceController = InterfaceController;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/controllers/MetaController.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":47}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.MetaController = void 0;\nconst fs_1 = __importDefault(require('fs'));\nconst path_1 = __importDefault(require('path'));\nclass MetaController {\n  static getVersion(req, res) {\n    try {\n      // Adjust path to point to package.json from dist or src logic\n      // Assuming compiled code runs from dist/src/controllers, package.json is in root (../..)\n      // Or if running via ts-node from src/controllers, it's also ../..\n      // Let's try to resolve it relative to process.cwd() which is usually the server root\n      const packagePath = path_1.default.join(process.cwd(), 'package.json');\n      if (!fs_1.default.existsSync(packagePath)) {\n        res.status(500).json({ error: 'Cannot find package.json' });\n        return;\n      }\n      const packageContent = fs_1.default.readFileSync(packagePath, 'utf-8');\n      const { version } = JSON.parse(packageContent);\n      res.json({ version });\n    } catch (error) {\n      console.error('Failed to read version:', error);\n      res.status(500).json({ error: 'Internal Server Error' });\n    }\n  }\n}\nexports.MetaController = MetaController;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/controllers/SessionController.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":73}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.SessionController = void 0;\nconst SessionRepository_1 = require('../repositories/SessionRepository');\nclass SessionController {\n  static listSessions(req, res) {\n    try {\n      const sessions = SessionRepository_1.sessionRepository.getAll();\n      // Sort by startTime (descending)\n      sessions.sort((a, b) => b.startTime - a.startTime);\n      res.json(sessions);\n    } catch (error) {\n      console.error('Error listing sessions:', error);\n      res.status(500).json({ error: 'Failed to list sessions' });\n    }\n  }\n}\nexports.SessionController = SessionController;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/db/Database.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":47}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.JsonDatabase = void 0;\nconst fs_1 = __importDefault(require('fs'));\nconst path_1 = __importDefault(require('path'));\nclass JsonDatabase {\n  constructor(filename) {\n    this.data = null;\n    const dataDir = path_1.default.join(process.cwd(), 'data');\n    if (!fs_1.default.existsSync(dataDir)) {\n      fs_1.default.mkdirSync(dataDir, { recursive: true });\n    }\n    this.filePath = path_1.default.join(dataDir, filename);\n  }\n  load() {\n    if (fs_1.default.existsSync(this.filePath)) {\n      try {\n        const content = fs_1.default.readFileSync(this.filePath, 'utf-8');\n        this.data = JSON.parse(content);\n      } catch (error) {\n        console.error(`Failed to load database from ${this.filePath}`, error);\n        this.data = null;\n      }\n    } else {\n      this.data = null;\n    }\n  }\n  save() {\n    try {\n      fs_1.default.writeFileSync(\n        this.filePath,\n        JSON.stringify(this.data, null, 2),\n      );\n    } catch (error) {\n      console.error(`Failed to save database to ${this.filePath}`, error);\n    }\n  }\n  read() {\n    if (this.data === null) {\n      this.load();\n    }\n    return this.data;\n  }\n  write(data) {\n    this.data = data;\n    this.save();\n  }\n}\nexports.JsonDatabase = JsonDatabase;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/index.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":8,"column":35,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":8,"endColumn":53},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":34,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":51},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":13,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":13,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":14,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":14,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":15,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":15,"endColumn":58},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":16,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":16,"endColumn":62},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":17,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":17,"endColumn":37},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":18,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":18,"endColumn":62},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":19,"column":28,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":19,"endColumn":66},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":20,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":20,"endColumn":62},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":21,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":21,"endColumn":60},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":62,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":62,"endColumn":67},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":63,"column":23,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":63,"endColumn":56}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nconst express_1 = __importDefault(require('express'));\nconst cors_1 = __importDefault(require('cors'));\nconst morgan_1 = __importDefault(require('morgan'));\nconst os_1 = __importDefault(require('os'));\nconst http_1 = __importDefault(require('http'));\nconst fs_1 = __importDefault(require('fs'));\nconst path_1 = __importDefault(require('path'));\nconst kafkaService_1 = require('./services/kafkaService');\nconst elasticService_1 = require('./services/elasticService');\nconst routes_1 = require('./routes');\nconst CleanupService_1 = require('./services/CleanupService');\nconst WebSocketService_1 = require('./services/WebSocketService');\nconst StorageService_1 = require('./services/StorageService');\nconst errorHandler_1 = require('./middleware/errorHandler');\nconst app = (0, express_1.default)();\nconst port = 3000;\n// Ensure uploads directory exists\nconst uploadsDir = path_1.default.join(__dirname, '../uploads');\nif (!fs_1.default.existsSync(uploadsDir)) {\n  fs_1.default.mkdirSync(uploadsDir, { recursive: true });\n}\n// Ensure database directory exists\nconst dbDir = path_1.default.join(__dirname, '../db');\nif (!fs_1.default.existsSync(dbDir)) {\n  fs_1.default.mkdirSync(dbDir, { recursive: true });\n}\n// Middleware\napp.use((0, cors_1.default)());\napp.use(express_1.default.json());\napp.use((0, morgan_1.default)('dev'));\n// Initialize storage (creates captures directory)\nStorageService_1.StorageService.init();\n// Start background services\nCleanupService_1.CleanupService.start();\napp.use('/api', routes_1.apiRouter);\n// Health check and System Monitor\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'ok',\n    uptime: process.uptime(),\n    timestamp: Date.now(),\n    memory: process.memoryUsage(),\n    load: os_1.default.loadavg(),\n    hostname: os_1.default.hostname(),\n  });\n});\n// 404 handler for unknown API routes\napp.use('/api/*', (req, res) => {\n  res.status(404).json({ error: 'Endpoint not found' });\n});\napp.use(errorHandler_1.errorHandler);\n// Create HTTP server and initialize WebSocket\nconst server = http_1.default.createServer(app);\nWebSocketService_1.WebSocketService.init(server);\nconst pcapWorkerManager_1 = require('./workers/pcapWorkerManager');\nconst yaraService_1 = require('./services/yaraService');\n// Initialize Services\n(async () => {\n  try {\n    await kafkaService_1.kafkaService.connect();\n    await elasticService_1.elasticService.connect();\n    await yaraService_1.yaraService.initialize();\n    await (0, pcapWorkerManager_1.startPcapWorker)();\n  } catch (e) {\n    console.error('Failed to initialize infrastructure services', e);\n  }\n})();\nserver.listen(port, '0.0.0.0', () => {\n  console.log(`Server running at http://0.0.0.0:${port}`);\n  console.log(`WebSocket server available at ws://0.0.0.0:${port}`);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/middleware/authMiddleware.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":40,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":27,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.authMiddleware = void 0;\nconst jsonwebtoken_1 = __importDefault(require('jsonwebtoken'));\nconst JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-key-change-in-prod';\nconst authMiddleware = (req, res, next) => {\n  // Check for Authorization header\n  const authHeader = req.headers.authorization;\n  if (!authHeader) {\n    res.status(401).json({ error: 'Authentication required' });\n    return;\n  }\n  const token = authHeader.split(' ')[1]; // Bearer <token>\n  if (!token) {\n    res.status(401).json({ error: 'Authentication required' });\n    return;\n  }\n  try {\n    const decoded = jsonwebtoken_1.default.verify(token, JWT_SECRET);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\nexports.authMiddleware = authMiddleware;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/middleware/errorHandler.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used.","line":4,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.errorHandler = void 0;\nconst errorHandler = (err, req, res, next) => {\n  // Log the error\n  console.error('API Error:', {\n    message: err.message,\n    stack: err.stack,\n    path: req.path,\n    method: req.method,\n  });\n  const statusCode = err.statusCode || 500;\n  const message = err.message || 'Internal Server Error';\n  res.status(statusCode).json({\n    error: message,\n    code: err.code,\n  });\n};\nexports.errorHandler = errorHandler;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/repositories/SessionRepository.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.sessionRepository = exports.SessionRepository = void 0;\nconst Database_1 = require('../db/Database');\nclass SessionRepository {\n  constructor() {\n    this.db = new Database_1.JsonDatabase('db.json');\n    // Initialize if empty\n    const data = this.db.read();\n    if (!data || !data.sessions) {\n      this.db.write({ sessions: [] });\n    }\n  }\n  getAll() {\n    return this.db.read().sessions;\n  }\n  getById(id) {\n    return this.db.read().sessions.find((s) => s.id === id);\n  }\n  create(session) {\n    const data = this.db.read();\n    data.sessions.push(session);\n    this.db.write(data);\n  }\n  update(id, updates) {\n    const data = this.db.read();\n    const index = data.sessions.findIndex((s) => s.id === id);\n    if (index !== -1) {\n      data.sessions[index] = { ...data.sessions[index], ...updates };\n      this.db.write(data);\n    }\n  }\n  delete(id) {\n    const data = this.db.read();\n    const initialLength = data.sessions.length;\n    data.sessions = data.sessions.filter((s) => s.id !== id);\n    if (data.sessions.length !== initialLength) {\n      this.db.write(data);\n    }\n  }\n}\nexports.SessionRepository = SessionRepository;\nexports.sessionRepository = new SessionRepository();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/routes/analysis.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":35,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":53},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":34,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":51},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":30,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":30,"endColumn":59},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":31,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":31,"endColumn":63}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.activeSessions = exports.analysisRouter = void 0;\nconst express_1 = __importDefault(require('express'));\nconst multer_1 = __importDefault(require('multer'));\nconst path_1 = __importDefault(require('path'));\nexports.analysisRouter = express_1.default.Router();\nconst storage = multer_1.default.diskStorage({\n  destination: (req, file, cb) => {\n    // Save to server/uploads\n    cb(null, path_1.default.join(__dirname, '../../uploads'));\n  },\n  filename: (req, file, cb) => {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);\n    cb(\n      null,\n      file.fieldname +\n        '-' +\n        uniqueSuffix +\n        path_1.default.extname(file.originalname),\n    );\n  },\n});\nconst upload = (0, multer_1.default)({ storage: storage });\nconst kafkaService_1 = require('../services/kafkaService');\nconst elasticService_1 = require('../services/elasticService');\n// Store active parsing sessions (in-memory for MVP status tracking, full data in ES)\nexports.activeSessions = {};\nexports.analysisRouter.post(\n  '/upload',\n  upload.single('pcap'),\n  async (req, res) => {\n    if (!req.file) {\n      return res.status(400).json({ error: 'No file uploaded' });\n    }\n    const filePath = req.file.path;\n    const sessionId = req.file.filename;\n    console.log(`File uploaded: ${filePath}, Session: ${sessionId}`);\n    // Initialize session state\n    exports.activeSessions[sessionId] = {\n      status: 'processing',\n      progress: 0,\n      error: null,\n      summary: {\n        packetCount: 0,\n        totalBytes: 0,\n      },\n    };\n    // Offload to Kafka Worker\n    try {\n      await kafkaService_1.kafkaService.produce('pcap-upload', {\n        filePath,\n        sessionId,\n      });\n      // Simulating the worker picking it up:\n      // In a real microservice, a separate worker process would consume this.\n      // For this MVP monolith, we'll start the processing logic \"as if\" triggered by Kafka if we wanted,\n      // OR we can actually implement the Consumer in this same process to read it back.\n      // Let's implement the Consumer listener in pcapService or index.ts to actually do the work.\n    } catch (err) {\n      console.error(`Failed to queue pcap for session ${sessionId}:`, err);\n      return res\n        .status(500)\n        .json({ error: 'Failed to queue file for processing' });\n    }\n    res.json({\n      sessionId,\n      status: 'processing',\n      originalName: req.file.originalname,\n      size: req.file.size,\n    });\n  },\n);\nexports.analysisRouter.get('/analysis/:sessionId/status', (req, res) => {\n  const { sessionId } = req.params;\n  const session = exports.activeSessions[sessionId];\n  // If session is not in memory (restart?), check ES for ANY packet to see if it exists?\n  // For MVP, keep using memory for status.\n  if (!session) {\n    return res.status(404).json({ error: 'Session not found' });\n  }\n  res.json({\n    status: session.status,\n    progress: session.progress,\n    packetCount: session.summary.packetCount,\n    error: session.error,\n  });\n});\nexports.analysisRouter.get('/analysis/:sessionId/results', async (req, res) => {\n  const { sessionId } = req.params;\n  // Pagination params\n  const from = parseInt(req.query.from) || 0;\n  const size = parseInt(req.query.size) || 100;\n  // Check if processing is done (optional, or just return what we have)\n  // const session = activeSessions[sessionId];\n  try {\n    const hits = await elasticService_1.elasticService.searchPackets(\n      sessionId,\n      size,\n      from,\n    );\n    // Map ES hits to clean Packet objects\n    const packets = hits.hits.map((hit) => hit._source);\n    res.json({\n      sessionId,\n      status: exports.activeSessions[sessionId]?.status || 'unknown',\n      summary: exports.activeSessions[sessionId]?.summary || {},\n      packets: packets,\n      total: hits.total.value,\n    });\n  } catch (e) {\n    console.error('Failed to fetch results from ES', e);\n    res.status(500).json({ error: 'Failed to fetch results' });\n  }\n});\nexports.analysisRouter.get('/analysis/:sessionId/stats', async (req, res) => {\n  const { sessionId } = req.params;\n  try {\n    const stats =\n      await elasticService_1.elasticService.getDashboardStats(sessionId);\n    if (!stats) {\n      return res.status(503).json({ error: 'Elasticsearch not connected' });\n    }\n    res.json(stats);\n  } catch (e) {\n    console.error('Failed to fetch stats from ES', e);\n    res.status(500).json({ error: 'Failed to fetch stats' });\n  }\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/routes/capture.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":37},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":31,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":76},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":6,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":6,"endColumn":72}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.captureRouter = void 0;\nconst express_1 = require('express');\nconst InterfaceController_1 = require('../controllers/InterfaceController');\nconst CaptureController_1 = require('../controllers/CaptureController');\nexports.captureRouter = (0, express_1.Router)();\nexports.captureRouter.get(\n  '/interfaces',\n  InterfaceController_1.InterfaceController.listInterfaces,\n);\nexports.captureRouter.post(\n  '/start',\n  CaptureController_1.CaptureController.startCapture,\n);\nexports.captureRouter.post(\n  '/stop',\n  CaptureController_1.CaptureController.stopCapture,\n);\nexports.captureRouter.post(\n  '/pause',\n  CaptureController_1.CaptureController.pauseCapture,\n);\nexports.captureRouter.post(\n  '/resume',\n  CaptureController_1.CaptureController.resumeCapture,\n);\nexports.captureRouter.get(\n  '/sessions',\n  CaptureController_1.CaptureController.listSessions,\n);\nexports.captureRouter.get(\n  '/stats',\n  CaptureController_1.CaptureController.getStats,\n);\nexports.captureRouter.get(\n  '/download/:id',\n  CaptureController_1.CaptureController.downloadCapture,\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/routes/index.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":37},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":39},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":41},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":66},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":13,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":13,"endColumn":65},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":14,"column":31,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":14,"endColumn":76},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":16,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":16,"endColumn":66},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":17,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":17,"endColumn":49},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":18,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":18,"endColumn":41},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":19,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":19,"endColumn":49}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.apiRouter = void 0;\nconst express_1 = require('express');\nconst capture_1 = require('./capture');\nconst analysis_1 = require('./analysis');\nconst AuthController_1 = require('../controllers/AuthController');\nconst authMiddleware_1 = require('../middleware/authMiddleware');\nconst InterfaceController_1 = require('../controllers/InterfaceController');\nexports.apiRouter = (0, express_1.Router)();\nconst MetaController_1 = require('../controllers/MetaController');\nconst yara_1 = __importDefault(require('./yara'));\nconst sessions_1 = require('./sessions');\nconst iocs_1 = __importDefault(require('./iocs'));\n// Public routes\nexports.apiRouter.get('/version', MetaController_1.MetaController.getVersion);\nexports.apiRouter.post('/auth/login', AuthController_1.AuthController.login);\n// Analysis routes (includes /upload - public for file upload)\nexports.apiRouter.use('/yara', yara_1.default);\nexports.apiRouter.use('/sessions', sessions_1.sessionRouter);\nexports.apiRouter.use('/iocs', iocs_1.default);\nexports.apiRouter.use('/', analysis_1.analysisRouter);\n// Protected routes\nexports.apiRouter.use(\n  '/capture',\n  authMiddleware_1.authMiddleware,\n  capture_1.captureRouter,\n);\n// Alias strict interface listing\nconst interfaceRouter = (0, express_1.Router)();\ninterfaceRouter.get(\n  '/',\n  InterfaceController_1.InterfaceController.listInterfaces,\n);\nexports.apiRouter.use(\n  '/interfaces',\n  authMiddleware_1.authMiddleware,\n  interfaceRouter,\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/routes/iocs.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":8,"column":35,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":8,"endColumn":53},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":22,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":16,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":45,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nconst express_1 = __importDefault(require('express'));\nconst iocService_1 = require('../services/iocService');\nconst router = express_1.default.Router();\n// GET /api/iocs\nrouter.get('/', (req, res) => {\n  try {\n    const iocs = iocService_1.iocService.getIocs();\n    res.json(iocs);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch IOCs' });\n  }\n});\n// POST /api/iocs\nrouter.post('/', (req, res) => {\n  try {\n    const { type, value, severity, description } = req.body;\n    if (!type || !value || !severity) {\n      return res.status(400).json({ error: 'Missing required fields' });\n    }\n    const newIoc = iocService_1.iocService.addIoc({\n      type,\n      value,\n      severity,\n      description,\n    });\n    res.status(201).json(newIoc);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Failed to add IOC' });\n  }\n});\n// DELETE /api/iocs/:id\nrouter.delete('/:id', (req, res) => {\n  try {\n    const { id } = req.params;\n    iocService_1.iocService.removeIoc(id);\n    res.status(200).json({ message: 'IOC removed' });\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to remove IOC' });\n  }\n});\nexports.default = router;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/routes/sessions.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":37},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":72}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.sessionRouter = void 0;\nconst express_1 = require('express');\nconst SessionController_1 = require('../controllers/SessionController');\nexports.sessionRouter = (0, express_1.Router)();\nexports.sessionRouter.get(\n  '/',\n  SessionController_1.SessionController.listSessions,\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/routes/yara.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":8,"column":35,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":8,"endColumn":53},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":23,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":21,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nconst express_1 = __importDefault(require('express'));\nconst yaraService_1 = require('../services/yaraService');\nconst router = express_1.default.Router();\n// GET /api/yara\nrouter.get('/', (req, res) => {\n  try {\n    const rules = yaraService_1.yaraService.getRules().map((r, index) => ({\n      id: String(index), // simple index ID for now\n      name: r.name,\n      content: r.source,\n      enabled: true,\n    }));\n    res.json(rules);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch rules' });\n  }\n});\n// POST /api/yara\nrouter.post('/', async (req, res) => {\n  try {\n    const { name, content } = req.body;\n    if (!name || !content) {\n      return res.status(400).json({ error: 'Missing name or content' });\n    }\n    await yaraService_1.yaraService.addRule(name, content);\n    res.status(201).json({ message: 'Rule added' });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Failed to add rule' });\n  }\n});\n// DELETE /api/yara/:id\n// Since we used index as ID effectively (or need logic in service):\n// yaraService currently doesn't have delete by ID, and stores simple array.\n// For MVP, implementing delete might require updating YaraService to assign IDs.\n// Skipping delete for now or will implement if time permits.\n// User requested \"work with server side\", editing rules on server is expected.\n// We should probably update YaraService to use IDs.\n// But for now, returning 501.\nrouter.delete('/:id', (req, res) => {\n  res.status(501).json({ error: 'Delete not implemented on server yet' });\n});\nexports.default = router;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/CaptureService.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":29},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":6,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":6,"endColumn":53}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.CaptureService = void 0;\n/// <reference path=\"../types/cap.d.ts\" />\nconst cap_1 = require('cap');\nconst CaptureSession_1 = require('./CaptureSession');\nclass CaptureService {\n  static getInterfaces() {\n    try {\n      const devices = cap_1.Cap.deviceList();\n      return devices.map((device) => ({\n        name: device.name,\n        addresses: device.addresses,\n        description: device.description || '',\n      }));\n    } catch (error) {\n      console.error('Error fetching interfaces:', error);\n      throw new Error('Failed to retrieve network interfaces');\n    }\n  }\n  static async startCapture(interfaceName, filter, sizeLimit) {\n    if (this.activeSessions.has(interfaceName)) {\n      throw new Error(`Capture already running on ${interfaceName}`);\n    }\n    const session = new CaptureSession_1.CaptureSession(interfaceName);\n    // The original start method had promiscuous: boolean = false.\n    // Since the new signature removes it, we'll assume it's handled internally by CaptureSession or defaults to false.\n    // The original filter and sizeLimit had default values, now they are optional.\n    // We pass them as they are, letting CaptureSession handle undefined values if necessary.\n    session.start(false, filter || '', sizeLimit || 0); // Assuming promiscuous defaults to false\n    this.activeSessions.set(interfaceName, session);\n    return session;\n  }\n  static stopCapture(interfaceName) {\n    const session = this.activeSessions.get(interfaceName);\n    if (!session) {\n      throw new Error(`No active capture on ${interfaceName}`);\n    }\n    session.stop();\n    this.activeSessions.delete(interfaceName);\n    return {\n      packetCount: session.packetCount,\n      output: session.outputFilePath,\n    };\n  }\n  static pauseCapture(interfaceName) {\n    const session = this.activeSessions.get(interfaceName);\n    if (!session) {\n      throw new Error(`No active capture on ${interfaceName}`);\n    }\n    session.pause();\n  }\n  static resumeCapture(interfaceName) {\n    const session = this.activeSessions.get(interfaceName);\n    if (!session) {\n      throw new Error(`No active capture on ${interfaceName}`);\n    }\n    session.resume();\n  }\n  static getCaptureStats(interfaceName) {\n    const session = this.activeSessions.get(interfaceName);\n    if (!session) {\n      throw new Error(`No active capture on ${interfaceName}`);\n    }\n    return session.getStats();\n  }\n  static getSessions() {\n    const sessions = [];\n    this.activeSessions.forEach((session) => {\n      sessions.push({\n        interface: session.interfaceName,\n        ...session.getStats(),\n      });\n    });\n    return sessions;\n  }\n}\nexports.CaptureService = CaptureService;\nCaptureService.activeSessions = new Map();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/CaptureSession.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":29},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":22,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":52},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":13,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":13,"endColumn":53},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":14,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":14,"endColumn":73},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":15,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":15,"endColumn":56},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":16,"column":28,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":16,"endColumn":57},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":17,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":17,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'promiscuous' is assigned a value but never used.","line":46,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'trunc' is defined but never used.","line":70,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":99,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":23},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":139,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":139,"endColumn":29}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.CaptureSession = void 0;\n/// <reference path=\"../types/cap.d.ts\" />\nconst cap_1 = require('cap');\nconst path_1 = __importDefault(require('path'));\nconst PcapWriter_1 = require('../utils/PcapWriter');\nconst StorageService_1 = require('./StorageService');\nconst SessionRepository_1 = require('../repositories/SessionRepository');\nconst PacketParser_1 = require('../utils/PacketParser');\nconst WebSocketService_1 = require('./WebSocketService');\nconst WebSocketMessages_1 = require('../types/WebSocketMessages');\nclass CaptureSession {\n  constructor(interfaceName) {\n    this.packetCount = 0;\n    this.writer = null;\n    this.running = false;\n    this.paused = false;\n    this.bytesWritten = 0;\n    this.sizeLimitBytes = 0;\n    this.diskCheckInterval = null;\n    this.id = `cap_${Date.now()}_${interfaceName}`;\n    this.interfaceName = interfaceName;\n    this.startTime = Date.now();\n    this.outputFilePath =\n      StorageService_1.StorageService.generatePath(interfaceName);\n    this.cap = new cap_1.Cap();\n    this.buffer = Buffer.alloc(65535);\n    // Create initial DB record\n    SessionRepository_1.sessionRepository.create({\n      id: this.id,\n      interfaceName: this.interfaceName,\n      startTime: this.startTime,\n      endTime: null,\n      status: 'running',\n      packetCount: 0,\n      sizeBytes: 0,\n      outputFilePath: this.outputFilePath,\n    });\n  }\n  start(promiscuous = false, filter = '', sizeLimitMB = 0) {\n    // On macOS, cap.open() requires the interface NAME (e.g., 'en0'), not the IP address\n    const target = this.interfaceName;\n    console.log(`CaptureSession: starting capture on interface '${target}'`);\n    if (sizeLimitMB > 0) {\n      this.sizeLimitBytes = sizeLimitMB * 1024 * 1024;\n    }\n    try {\n      const linkType = this.cap.open(\n        target,\n        filter,\n        10 * 1024 * 1024,\n        this.buffer,\n      );\n      // setMinBytes not available in all cap versions, removed\n      // Directory handled by StorageService\n      this.writer = new PcapWriter_1.PcapWriter(\n        this.outputFilePath,\n        typeof linkType === 'string' ? 1 : linkType,\n      ); // linkType from cap.open is string 'ETH' etc or number?\n      // node-cap documentation says it returns the link type (LINKTYPE_...) which is an integer usually.\n      // Let's cast it safely. If it returns 'ETHERNET' string, we need to map it.\n      // For now assume it returns the integer linktype as expected by pcap.\n      this.bytesWritten = 24; // Global header\n      this.cap.on('packet', (nBytes, trunc) => {\n        if (this.running && !this.paused && this.writer) {\n          this.packetCount++;\n          // nBytes is number of bytes received\n          // The data is in this.buffer.slice(0, nBytes)\n          const data = this.buffer.slice(0, nBytes);\n          this.writer.writePacket(data);\n          this.bytesWritten += 16 + data.length; // 16 bytes packet header + payload\n          if (\n            this.sizeLimitBytes > 0 &&\n            this.bytesWritten >= this.sizeLimitBytes\n          ) {\n            console.log(\n              `Size limit of ${this.sizeLimitBytes} bytes reached. Stopping capture.`,\n            );\n            this.stop();\n          }\n          // Parse and broadcast live packet\n          try {\n            const packetData = PacketParser_1.PacketParser.parse(\n              data,\n              Date.now(),\n            );\n            if (packetData) {\n              WebSocketService_1.WebSocketService.broadcast({\n                type: WebSocketMessages_1.WSMessageType.PACKET,\n                data: packetData,\n              });\n            }\n          } catch (err) {\n            // Silent fail for broadcast to not stop capture\n          }\n        }\n      });\n      this.running = true;\n      this.paused = false;\n      // Start disk space check interval (every 5 seconds)\n      this.startDiskCheck();\n      console.log(\n        `Started capture on ${this.interfaceName} (Target: ${target}). Output: ${this.outputFilePath}`,\n      );\n    } catch (e) {\n      console.error(`Failed to start capture on ${this.interfaceName}`, e);\n      throw e;\n    }\n  }\n  stop() {\n    if (this.running) {\n      this.running = false;\n      this.paused = false;\n      this.cap.close();\n      this.writer?.close();\n      if (this.diskCheckInterval) {\n        clearInterval(this.diskCheckInterval);\n        this.diskCheckInterval = null;\n      }\n      // Update DB record\n      SessionRepository_1.sessionRepository.update(this.id, {\n        endTime: Date.now(),\n        status: 'stopped',\n        packetCount: this.packetCount,\n        sizeBytes: this.bytesWritten,\n      });\n      console.log(\n        `Stopped capture on ${this.interfaceName}. captured ${this.packetCount} packets.`,\n      );\n    }\n  }\n  startDiskCheck() {\n    const fs = require('fs');\n    this.diskCheckInterval = setInterval(() => {\n      if (!this.running) return;\n      try {\n        // Check free space on the volume where captures are stored\n        // fs.statfs is available in Node 18+\n        if (fs.statfs) {\n          fs.statfs(\n            path_1.default.dirname(this.outputFilePath),\n            (err, stats) => {\n              if (err) {\n                console.error('Error checking disk space:', err);\n                return;\n              }\n              // stats.bavail: free blocks available to non-super user, stats.bsize: block size\n              const freeBytes = stats.bavail * stats.bsize;\n              // 100MB critical threshold\n              if (freeBytes < 100 * 1024 * 1024) {\n                console.warn(\n                  `Critical disk space (${Math.round(freeBytes / 1024 / 1024)}MB free). Stopping capture.`,\n                );\n                this.stop();\n              }\n            },\n          );\n        }\n      } catch (err) {\n        console.error('Disk check failed', err);\n      }\n    }, 5000);\n  }\n  pause() {\n    if (this.running) {\n      this.paused = true;\n      console.log(`Paused capture on ${this.interfaceName}`);\n    }\n  }\n  resume() {\n    if (this.running && this.paused) {\n      this.paused = false;\n      console.log(`Resumed capture on ${this.interfaceName}`);\n    }\n  }\n  isActive() {\n    return this.running;\n  }\n  isPaused() {\n    return this.paused;\n  }\n  getStats() {\n    return {\n      captured: this.packetCount,\n      dropped: 0, // Not available directly from cap event loop easily without implementing stats call\n      fileSize: this.bytesWritten,\n      duration: Date.now() - this.startTime,\n    };\n  }\n}\nexports.CaptureSession = CaptureSession;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/CleanupService.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":37,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":57},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":73}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.CleanupService = void 0;\nconst node_cron_1 = __importDefault(require('node-cron'));\nconst fs_1 = __importDefault(require('fs'));\nconst SessionRepository_1 = require('../repositories/SessionRepository');\nclass CleanupService {\n  static start() {\n    console.log('Starting automated cleanup service...');\n    node_cron_1.default.schedule(this.CRON_SCHEDULE, () => {\n      this.runCleanup();\n    });\n    // Run once on startup to clean old sessions immediately?\n    // Maybe better to let the schedule handle it or just log.\n    // For now, let's just schedule it.\n    console.log(`Cleanup service scheduled: ${this.CRON_SCHEDULE}`);\n  }\n  static runCleanup() {\n    console.log('Running automated session cleanup...');\n    try {\n      const sessions = SessionRepository_1.sessionRepository.getAll();\n      const now = Date.now();\n      let deletedCount = 0;\n      for (const session of sessions) {\n        // Check if session is finished/stopped and older than retention period\n        // Using startTime as simple age check\n        if (\n          ['finished', 'stopped'].includes(session.status) &&\n          now - session.startTime > this.RETENTION_PERIOD_MS\n        ) {\n          try {\n            console.log(\n              `Deleting expired session: ${session.id} (${new Date(session.startTime).toISOString()})`,\n            );\n            // Delete file\n            if (fs_1.default.existsSync(session.outputFilePath)) {\n              fs_1.default.unlinkSync(session.outputFilePath);\n            }\n            // Delete DB record\n            SessionRepository_1.sessionRepository.delete(session.id);\n            deletedCount++;\n          } catch (error) {\n            console.error(`Failed to delete session ${session.id}:`, error);\n          }\n        }\n      }\n      console.log(`Cleanup completed. Deleted ${deletedCount} sessions.`);\n    } catch (error) {\n      console.error('Error during session cleanup:', error);\n    }\n  }\n}\nexports.CleanupService = CleanupService;\n// 7 days in milliseconds\nCleanupService.RETENTION_PERIOD_MS = 7 * 24 * 60 * 60 * 1000;\n// Every day at midnight\nCleanupService.CRON_SCHEDULE = '0 0 * * *';\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/StorageService.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":31}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.StorageService = void 0;\nconst fs_1 = __importDefault(require('fs'));\nconst path_1 = __importDefault(require('path'));\nconst uuid_1 = require('uuid');\nclass StorageService {\n  static init() {\n    // Create captures directory\n    if (!fs_1.default.existsSync(this.CAPTURE_DIR)) {\n      fs_1.default.mkdirSync(this.CAPTURE_DIR, { recursive: true });\n      console.log(`Created capture directory: ${this.CAPTURE_DIR}`);\n    }\n    // Create uploads directory for PCAP file uploads\n    if (!fs_1.default.existsSync(this.UPLOADS_DIR)) {\n      fs_1.default.mkdirSync(this.UPLOADS_DIR, { recursive: true });\n      console.log(`Created uploads directory: ${this.UPLOADS_DIR}`);\n    }\n  }\n  static generatePath(interfaceName) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const filename = `capture-${timestamp}-${interfaceName}-${(0, uuid_1.v4)()}.pcap`;\n    return path_1.default.join(this.CAPTURE_DIR, filename);\n  }\n  static listFiles() {\n    if (!fs_1.default.existsSync(this.CAPTURE_DIR)) return [];\n    return fs_1.default\n      .readdirSync(this.CAPTURE_DIR)\n      .filter((f) => f.endsWith('.pcap'));\n  }\n  static getCaptureDir() {\n    return this.CAPTURE_DIR;\n  }\n}\nexports.StorageService = StorageService;\nStorageService.CAPTURE_DIR = path_1.default.join(process.cwd(), 'captures');\nStorageService.UPLOADS_DIR = path_1.default.join(process.cwd(), 'uploads');\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/WebSocketService.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":27},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":40,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":63},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'decoded' is assigned a value but never used.","line":37,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":42,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":48,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":34}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.WebSocketService = void 0;\nconst ws_1 = require('ws');\nconst jsonwebtoken_1 = __importDefault(require('jsonwebtoken'));\nconst WebSocketMessages_1 = require('../types/WebSocketMessages');\nconst JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-key-change-in-prod';\nclass WebSocketService {\n  static init(server) {\n    this.wss = new ws_1.WebSocketServer({ noServer: true });\n    server.on('upgrade', (request, socket, head) => {\n      this.handleUpgrade(request, socket, head);\n    });\n    this.wss.on('connection', (ws, req) => {\n      this.handleConnection(ws, req);\n    });\n    console.log('WebSocket server initialized.');\n  }\n  static handleUpgrade(request, socket, head) {\n    // Use WHATWG URL API instead of deprecated url.parse()\n    const reqUrl = new URL(\n      request.url || '',\n      `http://${request.headers.host || 'localhost'}`,\n    );\n    const token = reqUrl.searchParams.get('token');\n    if (!token) {\n      socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n      socket.destroy();\n      return;\n    }\n    try {\n      const decoded = jsonwebtoken_1.default.verify(token, JWT_SECRET);\n      // If verification succeeds, we're good.\n      this.wss.handleUpgrade(request, socket, head, (ws) => {\n        this.wss.emit('connection', ws, request);\n      });\n    } catch (err) {\n      socket.write('HTTP/1.1 403 Forbidden\\r\\n\\r\\n');\n      socket.destroy();\n      return;\n    }\n  }\n  static handleConnection(ws, req) {\n    console.log('New WebSocket connection established.');\n    ws.on('message', (message) => {\n      try {\n        const msg = JSON.parse(message.toString());\n        if (msg.type === WebSocketMessages_1.WSMessageType.UPDATE_FILTER) {\n          this.clientFilters.set(ws, msg.filters || {});\n          console.log('Filter updated for client:', msg.filters);\n        }\n      } catch (e) {\n        console.error('Failed to parse message:', e);\n      }\n    });\n    ws.on('close', () => {\n      this.clientFilters.delete(ws);\n      console.log('WebSocket connection closed.');\n    });\n  }\n  static matchesFilter(packet, filter) {\n    if (\n      filter.protocol &&\n      packet.protocol.toLowerCase() !== filter.protocol.toLowerCase()\n    ) {\n      return false;\n    }\n    if (filter.sourceIP && packet.sourceIP !== filter.sourceIP) {\n      return false;\n    }\n    if (filter.destinationIP && packet.destinationIP !== filter.destinationIP) {\n      return false;\n    }\n    if (\n      filter.port &&\n      packet.sourcePort !== filter.port &&\n      packet.destinationPort !== filter.port\n    ) {\n      return false;\n    }\n    return true;\n  }\n  static broadcast(message) {\n    if (!this.wss) return;\n    this.wss.clients.forEach((client) => {\n      if (client.readyState === ws_1.WebSocket.OPEN) {\n        // Apply per-client filter for PACKET messages\n        if (message.type === WebSocketMessages_1.WSMessageType.PACKET) {\n          const filter = this.clientFilters.get(client);\n          if (filter && Object.keys(filter).length > 0) {\n            if (!this.matchesFilter(message.data, filter)) {\n              return; // Skip this client\n            }\n          }\n        }\n        client.send(JSON.stringify(message));\n      }\n    });\n  }\n}\nexports.WebSocketService = WebSocketService;\nWebSocketService.clientFilters = new Map();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/elasticService.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":25,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":58}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.elasticService = exports.ElasticService = void 0;\nconst elasticsearch_1 = require('@elastic/elasticsearch');\nclass ElasticService {\n  constructor() {\n    this.isConnected = false;\n    this.PACKET_INDEX = 'pcap_packets';\n    this.client = new elasticsearch_1.Client({\n      node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200',\n    });\n  }\n  static getInstance() {\n    if (!ElasticService.instance) {\n      ElasticService.instance = new ElasticService();\n    }\n    return ElasticService.instance;\n  }\n  async connect() {\n    try {\n      const health = await this.client.cluster.health();\n      console.log('Connected to Elasticsearch:', health.status);\n      this.isConnected = true;\n      await this.ensureIndices();\n    } catch (error) {\n      console.error('Failed to connect to Elasticsearch:', error);\n      this.isConnected = false;\n    }\n  }\n  async ensureIndices() {\n    const exists = await this.client.indices.exists({\n      index: this.PACKET_INDEX,\n    });\n    const settings = {\n      index: {\n        max_result_window: 100000, // Increase limit for large PCAP pagination\n      },\n    };\n    if (!exists) {\n      await this.client.indices.create(\n        {\n          index: this.PACKET_INDEX,\n          settings: settings,\n          mappings: {\n            properties: {\n              sessionId: { type: 'keyword' },\n              timestamp: { type: 'date' },\n              sourceIp: { type: 'ip' },\n              destIp: { type: 'ip' },\n              protocol: { type: 'keyword' },\n              length: { type: 'integer' },\n              info: { type: 'text' },\n              raw: { type: 'binary' },\n              // New fields for extended analysis\n              strings: {\n                type: 'nested', // Use nested for rich querying later\n                properties: {\n                  value: { type: 'text' },\n                  type: { type: 'keyword' },\n                },\n              },\n              fileReferences: {\n                type: 'nested',\n                properties: {\n                  filename: { type: 'keyword' },\n                  mimeType: { type: 'keyword' },\n                  size: { type: 'long' },\n                },\n              },\n              threats: {\n                type: 'nested',\n                properties: {\n                  type: { type: 'keyword' },\n                  severity: { type: 'keyword' },\n                  description: { type: 'text' },\n                },\n              },\n              geoip: {\n                properties: {\n                  country: { type: 'keyword' }, // Store 2-letter country code\n                },\n              },\n            },\n          },\n        },\n        { ignore: [400] },\n      );\n      console.log(`Created index: ${this.PACKET_INDEX}`);\n    } else {\n      // Update settings for existing index\n      await this.client.indices.putSettings({\n        index: this.PACKET_INDEX,\n        body: {\n          index: {\n            max_result_window: 100000,\n          },\n        },\n      });\n      // Try to update mapping if new fields are missing (optional for MVP, might need close/open)\n      await this.client.indices\n        .putMapping({\n          index: this.PACKET_INDEX,\n          properties: {\n            geoip: {\n              properties: {\n                country: { type: 'keyword' },\n              },\n            },\n          },\n        })\n        .catch((e) => console.warn('Mapping update warning:', e.message));\n      console.log(`Updated settings for index: ${this.PACKET_INDEX}`);\n    }\n  }\n  async indexPacket(packet) {\n    if (!this.isConnected) return; // Or buffer\n    try {\n      await this.client.index({\n        index: this.PACKET_INDEX,\n        document: packet,\n      });\n    } catch (error) {\n      console.error('Failed to index packet:', error);\n      throw error;\n    }\n  }\n  async bulkIndexPackets(packets) {\n    if (!this.isConnected || packets.length === 0) return;\n    // Fix bulk body structure for Client 8.x/7.x compatibility\n    // The new client helper might be better, but sticking to basics:\n    const body = packets.flatMap((doc) => [\n      { index: { _index: this.PACKET_INDEX } },\n      doc,\n    ]);\n    try {\n      const response = await this.client.bulk({ body });\n      if (response.errors) {\n        console.error('Bulk index had errors');\n        const errorItems = response.items\n          .map((item) => item.index || item.create)\n          .filter((item) => item && item.error);\n        if (errorItems.length > 0) {\n          console.error(\n            'First error sample:',\n            JSON.stringify(errorItems[0]?.error, null, 2),\n          );\n        }\n      }\n    } catch (error) {\n      console.error('Failed to bulk index packets:', error);\n    }\n  }\n  async searchPackets(sessionId, size = 100, from = 0) {\n    if (!this.isConnected) return { hits: { hits: [], total: { value: 0 } } };\n    try {\n      const result = await this.client.search({\n        index: this.PACKET_INDEX,\n        from,\n        size,\n        query: {\n          term: { sessionId: sessionId },\n        },\n        sort: [{ timestamp: 'asc' }],\n      });\n      return result.hits;\n    } catch (error) {\n      console.error('Search failed:', error);\n      throw error;\n    }\n  }\n  async getDashboardStats(sessionId) {\n    if (!this.isConnected) return null;\n    try {\n      const result = await this.client.search({\n        index: this.PACKET_INDEX,\n        size: 0, // No documents needed, just aggregations\n        query: {\n          term: { sessionId: sessionId },\n        },\n        aggs: {\n          protocol_distribution: {\n            terms: { field: 'protocol', size: 20 },\n          },\n          traffic_over_time: {\n            date_histogram: {\n              field: 'timestamp',\n              fixed_interval: '1m', // Use fixed_interval for clearer buckets\n              min_doc_count: 0,\n            },\n            aggs: {\n              threat_packets: {\n                nested: {\n                  path: 'threats',\n                },\n              },\n            },\n          },\n          src_ips: {\n            terms: { field: 'sourceIp', size: 10 },\n          },\n          dest_ips: {\n            terms: { field: 'destIp', size: 10 },\n          },\n          threat_stats: {\n            nested: { path: 'threats' },\n            aggs: {\n              severity_counts: {\n                terms: { field: 'threats.severity' },\n              },\n              type_counts: {\n                terms: { field: 'threats.type' },\n              },\n              details: {\n                top_hits: {\n                  size: 100, // Fetch up to 100 threat details\n                },\n              },\n            },\n          },\n          file_stats: {\n            nested: { path: 'fileReferences' },\n            aggs: {\n              count: { value_count: { field: 'fileReferences.filename' } }, // Approximate count of files\n            },\n          },\n          geo_stats: {\n            terms: { field: 'geoip.country', size: 50 }, // Aggregate by country code\n          },\n        },\n      });\n      // Also fetch recent activity (last 5 packets) separately or in msearch\n      // For simplicity, do a separate small query for recent activity\n      const recent = await this.client.search({\n        index: this.PACKET_INDEX,\n        size: 5,\n        query: { term: { sessionId: sessionId } },\n        sort: [{ timestamp: 'desc' }],\n      });\n      return {\n        totalPackets: result.hits.total.value,\n        protocols: (result.aggregations?.protocol_distribution).buckets,\n        timeline: (result.aggregations?.traffic_over_time).buckets,\n        topTalkers: {\n          src: (result.aggregations?.src_ips).buckets,\n          dest: (result.aggregations?.dest_ips).buckets,\n        },\n        threats: {\n          bySeverity:\n            (result.aggregations?.threat_stats).severity_counts.buckets,\n          byType: (result.aggregations?.threat_stats).type_counts.buckets,\n          total: (result.aggregations?.threat_stats).doc_count,\n          list: result.aggregations?.threat_stats.details.hits.hits.map(\n            (h) => h._source,\n          ),\n        },\n        files: {\n          total:\n            (result.aggregations?.file_stats).count.value ||\n            (result.aggregations?.file_stats).doc_count,\n        },\n        geoDistribution: (result.aggregations?.geo_stats).buckets,\n        recentActivity: recent.hits.hits.map((h) => h._source),\n      };\n    } catch (error) {\n      console.error('Failed to get dashboard stats:', error);\n      throw error;\n    }\n  }\n}\nexports.ElasticService = ElasticService;\nexports.elasticService = ElasticService.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/iocService.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":47}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.iocService = exports.IocService = void 0;\nconst fs_1 = __importDefault(require('fs'));\nconst path_1 = __importDefault(require('path'));\nclass IocService {\n  constructor() {\n    this.iocs = [];\n    // Store in a simple JSON file for persistence across restarts\n    this.STORAGE_FILE = path_1.default.join(process.cwd(), 'data', 'iocs.json');\n    this.loadIocs();\n  }\n  static getInstance() {\n    if (!IocService.instance) {\n      IocService.instance = new IocService();\n    }\n    return IocService.instance;\n  }\n  loadIocs() {\n    try {\n      if (fs_1.default.existsSync(this.STORAGE_FILE)) {\n        const data = fs_1.default.readFileSync(this.STORAGE_FILE, 'utf-8');\n        this.iocs = JSON.parse(data);\n      } else {\n        // Ensure data dir exists\n        const dir = path_1.default.dirname(this.STORAGE_FILE);\n        if (!fs_1.default.existsSync(dir))\n          fs_1.default.mkdirSync(dir, { recursive: true });\n        this.iocs = [];\n      }\n    } catch (error) {\n      console.error('Failed to load IOCs:', error);\n      this.iocs = [];\n    }\n  }\n  saveIocs() {\n    try {\n      fs_1.default.writeFileSync(\n        this.STORAGE_FILE,\n        JSON.stringify(this.iocs, null, 2),\n      );\n    } catch (error) {\n      console.error('Failed to save IOCs:', error);\n    }\n  }\n  getIocs() {\n    return this.iocs;\n  }\n  addIoc(ioc) {\n    const newIoc = {\n      id: crypto.randomUUID(),\n      addedAt: new Date().toISOString(),\n      ...ioc,\n    };\n    this.iocs.push(newIoc);\n    this.saveIocs();\n    return newIoc;\n  }\n  addIocIfNotExists(ioc) {\n    const existing = this.iocs.find(\n      (i) => i.type === ioc.type && i.value === ioc.value,\n    );\n    if (existing) {\n      return existing;\n    }\n    return this.addIoc(ioc);\n  }\n  removeIoc(id) {\n    this.iocs = this.iocs.filter((i) => i.id !== id);\n    this.saveIocs();\n  }\n  // Check a packet against all IOCs\n  checkPacket(packet) {\n    const matches = [];\n    // Optimize: verify IPs specifically? For now, linear scan is okay for MVP size lists\n    for (const ioc of this.iocs) {\n      if (ioc.type === 'ip') {\n        if (packet.sourceIp === ioc.value || packet.destIp === ioc.value) {\n          matches.push(ioc);\n        }\n      } else if (ioc.type === 'domain') {\n        // Check if domain is in packet info or DNS layer if available\n        // Simple text match in info for now as fallback\n        if (packet.info && packet.info.includes(ioc.value)) {\n          matches.push(ioc);\n        }\n      } else if (ioc.type === 'hash') {\n        // Not supported on individual packet usually, unless file extracted.\n        // Skipped for packet-level check.\n      }\n    }\n    return matches;\n  }\n}\nexports.IocService = IocService;\nexports.iocService = IocService.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/kafkaService.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.kafkaService = exports.KafkaService = void 0;\nconst kafkajs_1 = require('kafkajs');\nclass KafkaService {\n  constructor() {\n    this.isConnected = false;\n    this.kafka = new kafkajs_1.Kafka({\n      clientId: 'net-pack-parser-server',\n      brokers: (process.env.KAFKA_BROKERS || 'localhost:9094').split(','), // Support comma-separated list\n      retry: {\n        initialRetryTime: 100,\n        retries: 8,\n      },\n    });\n    this.producer = this.kafka.producer();\n    this.consumer = this.kafka.consumer({ groupId: 'pcap-analysis-group' });\n  }\n  static getInstance() {\n    if (!KafkaService.instance) {\n      KafkaService.instance = new KafkaService();\n    }\n    return KafkaService.instance;\n  }\n  async connect() {\n    if (this.isConnected) return;\n    try {\n      await this.producer.connect();\n      await this.consumer.connect();\n      console.log('Successfully connected to Kafka/Redpanda');\n      this.isConnected = true;\n    } catch (error) {\n      console.error('Failed to connect to Kafka:', error);\n      // Don't throw, allow retries or app to start without it for dev\n    }\n  }\n  async produce(topic, message) {\n    if (!this.isConnected) {\n      // Try reconnecting?\n      await this.connect();\n      if (!this.isConnected) {\n        throw new Error('Kafka is not connected');\n      }\n    }\n    try {\n      await this.producer.send({\n        topic,\n        messages: [{ value: JSON.stringify(message) }],\n      });\n    } catch (error) {\n      console.error(`Failed to produce message to topic ${topic}:`, error);\n      throw error;\n    }\n  }\n  async subscribe(topic, handler) {\n    if (!this.isConnected) {\n      await this.connect();\n    }\n    await this.consumer.subscribe({ topic, fromBeginning: false });\n    await this.consumer.run({\n      eachMessage: async (payload) => {\n        try {\n          await handler(payload);\n        } catch (error) {\n          console.error('Error in Kafka consumer handler:', error);\n          // In a real app, handle DLQ (Dead Letter Queue) here\n        }\n      },\n    });\n  }\n  async disconnect() {\n    await this.producer.disconnect();\n    await this.consumer.disconnect();\n    this.isConnected = false;\n  }\n}\nexports.KafkaService = KafkaService;\nexports.kafkaService = KafkaService.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/pcapService.js","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":9,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":9,"endColumn":14,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[250,263],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":39,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":61},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":38,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":59},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":13,"column":27,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":13,"endColumn":62},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":14,"column":25,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":14,"endColumn":58},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":15,"column":27,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":15,"endColumn":62},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":16,"column":22,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":16,"endColumn":45},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":17,"column":23,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":17,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":18,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":18,"endColumn":31},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":19,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":19,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":48,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":17}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.parsePcapFile = void 0;\n// @ts-ignore\nconst pcap_parser_1 = __importDefault(require('pcap-parser'));\nconst geoip_lite_1 = __importDefault(require('geoip-lite'));\n// import { activeSessions } from '../routes/analysis'; // Decoupled for Worker Thread\nconst stringExtractor_1 = require('../utils/stringExtractor');\nconst fileExtractor_1 = require('../utils/fileExtractor');\nconst threatDetection_1 = require('../utils/threatDetection');\nconst iocService_1 = require('./iocService');\nconst yaraService_1 = require('./yaraService');\nconst uuid_1 = require('uuid');\nconst elasticService_1 = require('./elasticService');\nconst parsePcapFile = (filePath, sessionId, onProgress) => {\n  return new Promise((resolve, reject) => {\n    let packetCount = 0;\n    let batch = [];\n    const BATCH_SIZE = 500;\n    // Create parser\n    console.log(`[pcapService] Starting parse for ${filePath}`);\n    const parser = pcap_parser_1.default.parse(filePath);\n    parser.on('packet', async (packet) => {\n      packetCount++;\n      if (packetCount % 100 === 0)\n        console.log(`[pcapService] Parsed ${packetCount} packets...`);\n      const data = packet.data; // This is a Buffer\n      let offset = 14;\n      let srcIp = null;\n      let dstIp = null;\n      let protocol = 'Unknown';\n      try {\n        const etherType = data.readUInt16BE(12);\n        if (etherType === 0x0800) {\n          srcIp = `${data[offset + 12]}.${data[offset + 13]}.${data[offset + 14]}.${data[offset + 15]}`;\n          dstIp = `${data[offset + 16]}.${data[offset + 17]}.${data[offset + 18]}.${data[offset + 19]}`;\n          const proto = data[offset + 9];\n          if (proto === 6) protocol = 'TCP';\n          else if (proto === 17) protocol = 'UDP';\n          else if (proto === 1) protocol = 'ICMP';\n          else protocol = `IP(${proto})`;\n        }\n      } catch (e) {}\n      // Extended Analysis\n      const packetIdString = `${sessionId}-${packetCount}`;\n      // Pass minimal packet info needed for detection context\n      const packetInfoForDetection = {\n        id: packetIdString,\n        timestamp: new Date(\n          packet.header.timestampSeconds * 1000 +\n            packet.header.timestampMicroseconds / 1000,\n        ),\n        sourceIp: srcIp,\n        destIp: dstIp,\n        sourcePort: 0, // Need full parsing for ports, skipping for now\n        destPort: 0,\n      };\n      // GeoIP Lookup\n      let geoInfo = undefined;\n      if (srcIp) {\n        const geo = geoip_lite_1.default.lookup(srcIp);\n        if (geo && geo.country) {\n          geoInfo = { country: geo.country };\n        }\n      }\n      // Extract Strings\n      const strings = (0, stringExtractor_1.extractStringsFromBuffer)(\n        data,\n        packetIdString,\n      );\n      // Extract Files\n      const fileReferences = fileExtractor_1.fileExtractor.detectFileReferences(\n        {\n          ...packetInfoForDetection,\n          protocol,\n          sourcePort: 0, // Placeholder\n          destPort: 0, // Placeholder\n        },\n        data,\n      );\n      // Detect Threats\n      const threats = (0, threatDetection_1.runThreatDetection)(\n        packetInfoForDetection,\n        data,\n      );\n      // IOC Check\n      const iocMatches = iocService_1.iocService.checkPacket(\n        packetInfoForDetection,\n      );\n      iocMatches.forEach((ioc) => {\n        threats.push({\n          id: (0, uuid_1.v4)(),\n          packetId: packetInfoForDetection.id, // Ensure ID is string\n          severity: ioc.severity,\n          type: `IOC Match - ${ioc.type.toUpperCase()}`,\n          description: `Detected IOC: ${ioc.value}. ${ioc.description || ''}`,\n          mitreAttack: [],\n          timestamp: packetInfoForDetection.timestamp.getTime(),\n          sourceIp: packetInfoForDetection.sourceIp,\n          destIp: packetInfoForDetection.destIp,\n          sourcePort: 0,\n          destPort: 0,\n        });\n      });\n      // YARA Scan\n      try {\n        const yaraMatches = await yaraService_1.yaraService.scanPayload(data);\n        yaraMatches.forEach((match) => {\n          // Auto-extract IOC from Threat\n          if (packetInfoForDetection.sourceIp) {\n            iocService_1.iocService.addIocIfNotExists({\n              type: 'ip',\n              value: packetInfoForDetection.sourceIp,\n              severity: 'high',\n              description: `Auto-detected from YARA Rule: ${match.rule}`,\n            });\n          }\n          threats.push({\n            id: (0, uuid_1.v4)(),\n            packetId: packetInfoForDetection.id,\n            severity: 'high', // YARA matches usually correspond to specific malware rules\n            type: 'YARA Match',\n            description: `Rule: ${match.rule}`,\n            mitreAttack: [],\n            timestamp: packetInfoForDetection.timestamp.getTime(),\n            sourceIp: packetInfoForDetection.sourceIp,\n            destIp: packetInfoForDetection.destIp,\n            sourcePort: 0,\n            destPort: 0,\n          });\n        });\n      } catch (e) {\n        console.error(`YARA scan failed for packet ${packetCount}`, e);\n      }\n      const meta = {\n        sessionId,\n        timestamp: packetInfoForDetection.timestamp,\n        sourceIp: srcIp,\n        destIp: dstIp,\n        protocol: protocol,\n        length: packet.header.capturedLength,\n        info: `${protocol} Packet`,\n        raw: data.toString('base64'),\n        strings,\n        fileReferences,\n        threats,\n        geoip: geoInfo,\n      };\n      batch.push(meta);\n      if (batch.length >= BATCH_SIZE) {\n        const flushBatch = [...batch];\n        batch = [];\n        elasticService_1.elasticService\n          .bulkIndexPackets(flushBatch)\n          .catch((e) => console.error('Index error', e));\n        if (onProgress) {\n          onProgress(packetCount);\n        }\n      }\n    });\n    parser.on('end', async () => {\n      console.log(`[pcapService] Parsing ended. Total packets: ${packetCount}`);\n      if (batch.length > 0) {\n        await elasticService_1.elasticService.bulkIndexPackets(batch);\n      }\n      // Completion handled by caller (resolve)\n      resolve();\n    });\n    parser.on('error', (err) => {\n      console.error(`[pcapService] Parser Error:`, err);\n      reject(err);\n    });\n  });\n};\nexports.parsePcapFile = parsePcapFile;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/services/yaraService.js","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":9,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":9,"endColumn":14,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[270,283],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":40,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":63},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":100,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":110,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":15}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.yaraService = exports.YaraService = void 0;\n// @ts-ignore\nconst libyara_wasm_1 = __importDefault(require('libyara-wasm'));\nconst fs_1 = __importDefault(require('fs'));\nconst path_1 = __importDefault(require('path'));\nclass YaraService {\n  constructor() {\n    this.yaraInstance = null;\n    this.rules = []; // Store compiled rules? Or source?\n    // libyara-wasm usually compiles a source string into a scanner/module.\n    // We might need to keep the \"scanner\" state.\n    // Simple in-memory storage for rule sources for now\n    this.ruleSources = [];\n    this.scanner = null;\n    this.initialized = false;\n    this.RULES_FILE = path_1.default.join(\n      process.cwd(),\n      'data',\n      'yara_rules.json',\n    );\n    this.loadStoredRules();\n  }\n  static getInstance() {\n    if (!YaraService.instance) {\n      YaraService.instance = new YaraService();\n    }\n    return YaraService.instance;\n  }\n  async initialize() {\n    if (this.initialized) return;\n    try {\n      // Initialize WASM\n      this.yaraInstance = await (0, libyara_wasm_1.default)();\n      this.initialized = true;\n      console.log('YARA WASM initialized');\n      // Compile existing rules\n      await this.compileRules();\n    } catch (error) {\n      console.error('Failed to initialize YARA:', error);\n    }\n  }\n  loadStoredRules() {\n    try {\n      if (fs_1.default.existsSync(this.RULES_FILE)) {\n        this.ruleSources = JSON.parse(\n          fs_1.default.readFileSync(this.RULES_FILE, 'utf-8'),\n        );\n      } else {\n        const dir = path_1.default.dirname(this.RULES_FILE);\n        if (!fs_1.default.existsSync(dir))\n          fs_1.default.mkdirSync(dir, { recursive: true });\n        // Add a default rule for testing\n        // Add default rules for demo scenarios\n        this.ruleSources = [\n          {\n            name: 'SQLInjection_Classic',\n            source:\n              \"rule SQLInjection_Classic { strings: $a = \\\"OR '1'='1\\\" condition: $a }\",\n          },\n          {\n            name: 'SQLInjection_Union',\n            source:\n              'rule SQLInjection_Union { strings: $a = \"UNION SELECT\" nocase condition: $a }',\n          },\n          {\n            name: 'XSS_Attack',\n            source:\n              'rule XSS_Attack { strings: $a = \"<script>\" nocase condition: $a }',\n          },\n          {\n            name: 'Suspicious_JSON_Cmd',\n            source:\n              'rule Suspicious_JSON_Cmd { strings: $a = \"\\\\\"cmd\\\\\": \\\\\"exec\\\\\"\" condition: $a }',\n          },\n          {\n            name: 'Malicious_Site',\n            source:\n              'rule Malicious_Site { strings: $a = \"Host: malicious-site.com\" nocase condition: $a }',\n          },\n          {\n            name: 'Command_Injection_Eval',\n            source:\n              'rule Command_Injection_Eval { strings: $a = \"eval(document.cookie)\" condition: $a }',\n          },\n          {\n            name: 'Test_Rule_HTTP',\n            source:\n              'rule Test_Rule_HTTP { strings: $a = \"HTTP\" condition: $a }',\n          },\n        ];\n        this.saveRules();\n      }\n    } catch (e) {\n      this.ruleSources = [];\n    }\n  }\n  saveRules() {\n    try {\n      fs_1.default.writeFileSync(\n        this.RULES_FILE,\n        JSON.stringify(this.ruleSources, null, 2),\n      );\n    } catch (e) {}\n  }\n  async compileRules() {\n    // No-op: libyara-wasm compiles during run\n  }\n  async scanPayload(buffer) {\n    if (!this.yaraInstance) return [];\n    try {\n      // libyara-wasm expects a binary string (latin1) for the payload\n      // Efficiently build string from buffer\n      let payloadStr = '';\n      const chunkSize = 0x8000;\n      for (let i = 0; i < buffer.length; i += chunkSize) {\n        payloadStr += String.fromCharCode.apply(\n          null,\n          buffer.subarray(i, i + chunkSize),\n        );\n      }\n      const activeRules = this.ruleSources.map((r) => r.source).join('\\n');\n      if (!activeRules.trim()) return [];\n      const result = this.yaraInstance.run(payloadStr, activeRules);\n      const matches = [];\n      if (result.matchedRules) {\n        for (let i = 0; i < result.matchedRules.size(); i++) {\n          const match = result.matchedRules.get(i);\n          const resolvedMatches = [];\n          if (match.resolvedMatches) {\n            for (let j = 0; j < match.resolvedMatches.size(); j++) {\n              const rm = match.resolvedMatches.get(j);\n              resolvedMatches.push({\n                offset: rm.location,\n                length: rm.matchLength || rm.match_length,\n                data: rm.data,\n              });\n            }\n          }\n          matches.push({\n            rule: match.ruleName || match.rule_name,\n            tags: [], // Metadata/Tags extraction if needed\n            matches: resolvedMatches,\n          });\n        }\n      }\n      if (result.delete) result.delete();\n      return matches;\n    } catch (error) {\n      console.error('YARA Scan failed:', error);\n      return [];\n    }\n  }\n  async addRule(name, source) {\n    this.ruleSources.push({ name, source });\n    this.saveRules();\n    await this.compileRules();\n  }\n  getRules() {\n    return this.ruleSources;\n  }\n}\nexports.YaraService = YaraService;\nexports.yaraService = YaraService.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/types/WebSocketMessages.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/utils/PacketParser.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'summary' is assigned a value but never used.","line":52,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":52,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":69,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.PacketParser = void 0;\nconst uuid_1 = require('uuid');\nclass PacketParser {\n  static parse(buffer, timestamp) {\n    // Basic parsing for Ethernet II / IPv4\n    // TODO: Add support for IPv6, etc.\n    try {\n      // Ethernet Header (14 bytes)\n      // Destination MAC (6), Source MAC (6), EtherType (2)\n      const etherType = buffer.readUInt16BE(12);\n      let protocol = 'Unknown';\n      let sourceIP = 'Unknown';\n      let destinationIP = 'Unknown';\n      let sourcePort = 0;\n      let destinationPort = 0;\n      let summary = '';\n      // IPv4\n      if (etherType === 0x0800) {\n        const ipOffset = 14;\n        // Version + IHL\n        const verIhl = buffer[ipOffset];\n        const ihl = (verIhl & 0x0f) * 4; // Header length in bytes\n        // Protocol\n        const proto = buffer[ipOffset + 9];\n        // IPs\n        sourceIP = `${buffer[ipOffset + 12]}.${buffer[ipOffset + 13]}.${buffer[ipOffset + 14]}.${buffer[ipOffset + 15]}`;\n        destinationIP = `${buffer[ipOffset + 16]}.${buffer[ipOffset + 17]}.${buffer[ipOffset + 18]}.${buffer[ipOffset + 19]}`;\n        const transportOffset = ipOffset + ihl;\n        if (proto === 6) {\n          protocol = 'TCP';\n          sourcePort = buffer.readUInt16BE(transportOffset);\n          destinationPort = buffer.readUInt16BE(transportOffset + 2);\n        } else if (proto === 17) {\n          protocol = 'UDP';\n          sourcePort = buffer.readUInt16BE(transportOffset);\n          destinationPort = buffer.readUInt16BE(transportOffset + 2);\n        } else if (proto === 1) {\n          protocol = 'ICMP';\n        } else {\n          protocol = `IP(${proto})`;\n        }\n      } else if (etherType === 0x86dd) {\n        protocol = 'IPv6';\n        // IPv6 parsing placeholder\n      } else if (etherType === 0x0806) {\n        protocol = 'ARP';\n      } else {\n        protocol = `Eth(${etherType.toString(16)})`;\n      }\n      summary = `${protocol} ${sourceIP}:${sourcePort} -> ${destinationIP}:${destinationPort}`;\n      return {\n        id: (0, uuid_1.v4)(),\n        timestamp,\n        protocol,\n        sourceIP,\n        destinationIP,\n        sourcePort,\n        destinationPort,\n        length: buffer.length,\n        summary: `${protocol} ${sourceIP}:${sourcePort} -> ${destinationIP}:${destinationPort}`,\n        severity: 'low', // Default severity\n        payload:\n          buffer.length > 2048\n            ? buffer.subarray(0, 2048).toString('base64')\n            : buffer.toString('base64'),\n      };\n    } catch (error) {\n      // console.error('Error parsing packet:', error);\n      return null;\n    }\n  }\n}\nexports.PacketParser = PacketParser;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/utils/PcapWriter.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":43}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.PcapWriter = void 0;\nconst fs_1 = __importDefault(require('fs'));\nclass PcapWriter {\n  constructor(filePath, linkType) {\n    this.stream = fs_1.default.createWriteStream(filePath);\n    this.writeGlobalHeader(linkType);\n  }\n  writeGlobalHeader(linkType) {\n    const buffer = Buffer.alloc(24);\n    // Magic Number (0xa1b2c3d4)\n    buffer.writeUInt32LE(0xa1b2c3d4, 0);\n    // Major Version (2)\n    buffer.writeUInt16LE(2, 4);\n    // Minor Version (4)\n    buffer.writeUInt16LE(4, 6);\n    // This zone (0)\n    buffer.writeUInt32LE(0, 8);\n    // Sig figs (0)\n    buffer.writeUInt32LE(0, 12);\n    // Snaplen (65535)\n    buffer.writeUInt32LE(65535, 16);\n    // Network (Link Layer Type)\n    buffer.writeUInt32LE(linkType, 20);\n    this.stream.write(buffer);\n  }\n  writePacket(\n    packetData,\n    bytesCaptured = packetData.length,\n    originalLength = packetData.length,\n  ) {\n    const buffer = Buffer.alloc(16);\n    const now = Date.now();\n    const sec = Math.floor(now / 1000);\n    const usec = (now % 1000) * 1000;\n    // Timestamp seconds\n    buffer.writeUInt32LE(sec, 0);\n    // Timestamp microseconds\n    buffer.writeUInt32LE(usec, 4);\n    // Included length (bytes saved)\n    buffer.writeUInt32LE(bytesCaptured, 8);\n    // Original length (actual length on wire)\n    buffer.writeUInt32LE(originalLength, 12);\n    this.stream.write(buffer);\n    this.stream.write(packetData);\n  }\n  close() {\n    this.stream.end();\n  }\n}\nexports.PcapWriter = PcapWriter;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/utils/fileExtractor.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.fileExtractor = exports.FileExtractor = void 0;\nconst uuid_1 = require('uuid');\nclass FileExtractor {\n  constructor() {\n    this.ftpControlToDataPort = new Map();\n  }\n  getControlKey(packet) {\n    // packet.sourceIp / destIp are verified to be strings now or null.\n    // If null return empty\n    if (!packet.sourceIp || !packet.destIp) return '';\n    if (packet.destPort === 21)\n      return `${packet.sourceIp}:${packet.sourcePort}`;\n    if (packet.sourcePort === 21) return `${packet.destIp}:${packet.destPort}`;\n    return '';\n  }\n  parseHttpHeaders(httpResponseString) {\n    const headers = {};\n    const headerLines = httpResponseString.split('\\r\\n');\n    for (let i = 1; i < headerLines.length; i++) {\n      const line = headerLines[i];\n      if (line.trim() === '') break;\n      const parts = line.split(':');\n      if (parts.length > 1) {\n        const key = parts[0].trim().toLowerCase();\n        const value = parts.slice(1).join(':').trim();\n        headers[key] = value;\n      }\n    }\n    return headers;\n  }\n  detectFileReferences(packet, rawData) {\n    const detectedFiles = [];\n    const payloadString = rawData.toString('utf-8'); // Expensive for large packets?\n    // HTTP\n    if (packet.protocol === 'HTTP' && payloadString.startsWith('HTTP/')) {\n      const headers = this.parseHttpHeaders(payloadString);\n      const contentType = headers['content-type'];\n      const contentDisposition = headers['content-disposition'];\n      const contentLength = parseInt(headers['content-length'] || '0', 10);\n      let filename;\n      if (contentDisposition) {\n        const filenameMatch = /filename\\*?=['\"]?(?:UTF-8''|)([^;\"]+)['\"]?/.exec(\n          contentDisposition,\n        );\n        if (filenameMatch && filenameMatch[1]) {\n          filename = decodeURIComponent(filenameMatch[1]);\n        }\n      }\n      if (!filename && contentType) {\n        filename = `unknown_file.${contentType.split('/')[1] || 'bin'}`;\n      }\n      const isFileContentType =\n        contentType &&\n        FileExtractor.HTTP_FILE_CONTENT_TYPES.some((regex) =>\n          regex.test(contentType),\n        );\n      if (filename && isFileContentType && contentLength > 0) {\n        const headerEndIndex = rawData.indexOf('\\r\\n\\r\\n');\n        if (headerEndIndex !== -1) {\n          // We found a file!\n          // We verify size matches logic?\n          detectedFiles.push({\n            id: (0, uuid_1.v4)(),\n            filename: filename,\n            size: contentLength,\n            mimeType: contentType || 'application/octet-stream',\n            sourcePacketId: String(packet.id),\n            dataOffset: headerEndIndex + 4,\n          });\n        }\n      }\n    }\n    // FTP\n    if (\n      packet.protocol === 'FTP' ||\n      packet.destPort === 21 ||\n      packet.sourcePort === 21\n    ) {\n      const key = this.getControlKey(packet);\n      if (key) {\n        // Check PORT\n        const portMatch = payloadString.match(\n          /PORT\\s+(\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)/,\n        );\n        if (portMatch) {\n          const p1 = parseInt(portMatch[5], 10);\n          const p2 = parseInt(portMatch[6], 10);\n          const port = p1 * 256 + p2;\n          this.ftpControlToDataPort.set(key, port);\n        }\n        // PASV\n        const pasvMatch = payloadString.match(\n          /227.*\\((\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)\\)/,\n        );\n        if (pasvMatch) {\n          const p1 = parseInt(pasvMatch[5], 10);\n          const p2 = parseInt(pasvMatch[6], 10);\n          const port = p1 * 256 + p2;\n          this.ftpControlToDataPort.set(key, port);\n        }\n        // STOR/RETR\n        const ftpCommandMatch = payloadString.match(/(STOR|RETR)\\s+([^\\r\\n]+)/);\n        if (ftpCommandMatch) {\n          const command = ftpCommandMatch[1];\n          const filename = ftpCommandMatch[2].trim();\n          const dataPort = this.ftpControlToDataPort.get(key);\n          detectedFiles.push({\n            id: (0, uuid_1.v4)(),\n            filename,\n            size: 0,\n            mimeType: 'application/octet-stream',\n            sourcePacketId: String(packet.id),\n            ftpDataPort: dataPort,\n            ftpTransferType: command,\n          });\n        }\n      }\n    }\n    return detectedFiles;\n  }\n}\nexports.FileExtractor = FileExtractor;\nFileExtractor.HTTP_FILE_CONTENT_TYPES = [\n  /^application\\//,\n  /^image\\//,\n  /^video\\//,\n  /^audio\\//,\n  /^font\\//,\n  /^text\\/(?!html|css|javascript|plain)/,\n];\nexports.fileExtractor = new FileExtractor();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/utils/stringExtractor.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FILE_PATH_REGEX' is assigned a value but never used.","line":13,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.extractStringsFromBuffer = extractStringsFromBuffer;\nconst uuid_1 = require('uuid');\n// Regex patterns (Same as client)\nconst IPV4_REGEX =\n  /\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/g;\n// const IPV6_REGEX = /\\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\\b/g; // Simplified for now, often matches random hex\nconst URL_REGEX = /(?:https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*/gi;\nconst EMAIL_REGEX = /\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b/gi;\nconst CREDENTIAL_REGEX =\n  /\\b(?:user(?:name)?|pass(?:word)?|api_key|token|auth|bearer|secret)(?:[=\\s:]+)?['\"]?([A-Z0-9._%+-]+)['\"]?\\b/gi;\nconst FILE_PATH_REGEX =\n  /(?:[a-zA-Z]:\\\\(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]+)|(?:(?:\\/[^/ ]*)+\\/?)/g;\nconst MIN_PRINTABLE_STRING_LENGTH = 4;\nfunction extractStringsFromBuffer(payload, packetId, payloadOffset = 0) {\n  const extracted = [];\n  // Convert buffer to string, replacing non-printable/invalid chars might be safer for regex\n  // But 'utf-8' decode is standard\n  const payloadString = payload.toString('utf-8');\n  const addExtracted = (type, value, index, length) => {\n    if (\n      !extracted.some(\n        (e) => e.value === value && e.payloadOffset === payloadOffset + index,\n      )\n    ) {\n      extracted.push({\n        id: (0, uuid_1.v4)(),\n        type,\n        value,\n        packetId,\n        payloadOffset: payloadOffset + index,\n        length,\n      });\n    }\n  };\n  // 1. Regex-based\n  const extractWithRegex = (regex, type) => {\n    regex.lastIndex = 0;\n    let match;\n    while ((match = regex.exec(payloadString)) !== null) {\n      const valueToExtract =\n        type === 'Credential' && match[1] ? match[1] : match[0];\n      const index =\n        type === 'Credential' && match[1]\n          ? match.index + match[0].indexOf(match[1])\n          : match.index;\n      if (\n        valueToExtract &&\n        valueToExtract.length >= MIN_PRINTABLE_STRING_LENGTH\n      ) {\n        addExtracted(type, valueToExtract, index, valueToExtract.length);\n      }\n    }\n  };\n  extractWithRegex(IPV4_REGEX, 'IP');\n  extractWithRegex(URL_REGEX, 'URL');\n  extractWithRegex(EMAIL_REGEX, 'Email');\n  extractWithRegex(CREDENTIAL_REGEX, 'Credential');\n  // extractWithRegex(FILE_PATH_REGEX, 'FilePath'); // Too noisy usually, enable if needed\n  // 2. Printable Strings\n  // Basic loop for printable chars\n  let currentString = '';\n  let startIndex = -1;\n  for (let i = 0; i < payload.length; i++) {\n    const byte = payload[i];\n    if (byte >= 0x20 && byte <= 0x7e) {\n      if (startIndex === -1) startIndex = i;\n      currentString += String.fromCharCode(byte);\n    } else {\n      if (currentString.length >= MIN_PRINTABLE_STRING_LENGTH) {\n        // Optimization: Don't add if we already found it via regex logic?\n        // Or just add as 'Other'\n        addExtracted('Other', currentString, startIndex, currentString.length);\n      }\n      currentString = '';\n      startIndex = -1;\n    }\n  }\n  if (currentString.length >= MIN_PRINTABLE_STRING_LENGTH) {\n    addExtracted('Other', currentString, startIndex, currentString.length);\n  }\n  return extracted;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/utils/threatDetection.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.runThreatDetection = runThreatDetection;\nconst uuid_1 = require('uuid');\n// Patterns adapted from client logic\nconst SQL_INJECTION_PATTERNS = [\n  /UNION\\s+SELECT/i,\n  /OR\\s+1=1/i,\n  /DROP\\s+TABLE/i,\n  /INSERT\\s+INTO/i,\n  /UPDATE\\s+.*SET/i,\n  /--/, // Comment - prone to false positives, be careful or keep severity low\n];\nconst XSS_PATTERNS = [\n  /<script>/i,\n  /javascript:/i,\n  /onload=/i,\n  /onerror=/i,\n  /alert\\(/i,\n];\nconst COMMAND_INJECTION_PATTERNS = [\n  /;\\s*(?:cat|ls|pwd|whoami)\\b/,\n  /\\|\\s*(?:cat|ls|pwd|whoami)\\b/,\n  /`.*(?:cat|ls|pwd|whoami).*`/,\n];\nconst SENSITIVE_DATA_PATTERNS = [\n  /\\b\\d{3}-\\d{2}-\\d{4}\\b/, // SSN\n  /\\b(?:\\d[ -]*?){13,16}\\b/, // Credit Card (Simple)\n];\nfunction runThreatDetection(packet, rawData) {\n  const alerts = [];\n  const payloadString = rawData.toString('utf-8');\n  const addAlert = (type, description, severity, mitre) => {\n    alerts.push({\n      id: (0, uuid_1.v4)(),\n      packetId: String(packet.id),\n      severity,\n      type,\n      description,\n      mitreAttack: mitre,\n      timestamp: packet.timestamp.getTime\n        ? packet.timestamp.getTime()\n        : new Date(packet.timestamp).getTime(),\n      sourceIp: packet.sourceIp,\n      destIp: packet.destIp,\n      sourcePort: 0, // Need to parse from packet? Or keep 0 if unknown\n      destPort: 0,\n    });\n  };\n  // SQL Injection\n  for (const pattern of SQL_INJECTION_PATTERNS) {\n    if (pattern.test(payloadString)) {\n      addAlert('Injection', 'Possible SQL Injection Detected', 'high', [\n        'T1190',\n      ]);\n      break; // Report once per type\n    }\n  }\n  // XSS\n  for (const pattern of XSS_PATTERNS) {\n    if (pattern.test(payloadString)) {\n      addAlert('Cross-Site Scripting', 'Possible XSS Detected', 'medium', [\n        'T1059.007',\n      ]);\n      break;\n    }\n  }\n  // Command Injection\n  for (const pattern of COMMAND_INJECTION_PATTERNS) {\n    if (pattern.test(payloadString)) {\n      addAlert(\n        'Command Injection',\n        'Possible OS Command Injection Detected',\n        'critical',\n        ['T1059.004'],\n      );\n      break;\n    }\n  }\n  // Sensitive Data\n  for (const pattern of SENSITIVE_DATA_PATTERNS) {\n    if (pattern.test(payloadString)) {\n      addAlert(\n        'Sensitive Data',\n        'Potential PII/Credit Card Data Exposed',\n        'high',\n        ['T1001'],\n      );\n      break;\n    }\n  }\n  return alerts;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/verify-cap.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n/// <reference path=\"./types/cap.d.ts\" />\nconst cap_1 = require('cap');\nconsole.log('Verifying Cap installation...');\ntry {\n  const devices = cap_1.Cap.deviceList();\n  console.log('Cap loaded successfully!');\n  console.log(`Found ${devices.length} network interfaces.`);\n  devices.forEach((d) =>\n    console.log(` - ${d.name} (${d.addresses.length} addresses)`),\n  );\n} catch (err) {\n  console.error('Failed to load Cap or list devices:', err);\n  process.exit(1);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/workers/pcap.worker.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":51},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":23,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":57},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":63},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":6,"column":23,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":6,"endColumn":57}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst worker_threads_1 = require('worker_threads');\nconst pcapService_1 = require('../services/pcapService');\nconst elasticService_1 = require('../services/elasticService');\nconst yaraService_1 = require('../services/yaraService');\n(async () => {\n  try {\n    const { filePath, sessionId } = worker_threads_1.workerData;\n    console.log(`[Worker] Started for session ${sessionId}`);\n    console.log(`[Worker] Elastic URL: ${process.env.ELASTICSEARCH_URL}`);\n    console.log(`[Worker] File Path: ${filePath}`);\n    // Initialize services in this thread\n    await elasticService_1.elasticService.connect();\n    await yaraService_1.yaraService.initialize();\n    await (0, pcapService_1.parsePcapFile)(filePath, sessionId, (count) => {\n      worker_threads_1.parentPort?.postMessage({\n        type: 'progress',\n        sessionId,\n        count,\n      });\n    });\n    worker_threads_1.parentPort?.postMessage({\n      type: 'complete',\n      sessionId,\n    });\n  } catch (error) {\n    console.error('Worker error:', error);\n    worker_threads_1.parentPort?.postMessage({\n      type: 'error',\n      error,\n    });\n  }\n})();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/workers/pcapWorker.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":59},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":23,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":57}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.startPcapWorker = void 0;\nconst kafkaService_1 = require('../services/kafkaService');\nconst pcapService_1 = require('../services/pcapService');\nconst startPcapWorker = async () => {\n  console.log('Starting PCAP Worker...');\n  // Subscribe to PCAP upload topic\n  await kafkaService_1.kafkaService.subscribe(\n    'pcap-upload',\n    async (payload) => {\n      if (!payload.message.value) return;\n      const event = JSON.parse(payload.message.value.toString());\n      const { filePath, sessionId } = event;\n      console.log(`Worker received task: Parse ${sessionId}`);\n      try {\n        await (0, pcapService_1.parsePcapFile)(filePath, sessionId);\n        console.log(`Worker finished task: Parse ${sessionId}`);\n      } catch (error) {\n        console.error(`Worker failed task ${sessionId}:`, error);\n      }\n    },\n  );\n};\nexports.startPcapWorker = startPcapWorker;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/dist/workers/pcapWorkerManager.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":59},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":51},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerPath' is assigned a value but never used.","line":24,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":23}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.startPcapWorker = void 0;\nconst kafkaService_1 = require('../services/kafkaService');\nconst worker_threads_1 = require('worker_threads');\nconst path_1 = __importDefault(require('path'));\nconst analysis_1 = require('../routes/analysis');\nconst startPcapWorker = async () => {\n  console.log('Starting PCAP Worker...');\n  // Subscribe to PCAP upload topic\n  await kafkaService_1.kafkaService.subscribe(\n    'pcap-upload',\n    async (payload) => {\n      if (!payload.message.value) return;\n      const event = JSON.parse(payload.message.value.toString());\n      const { filePath, sessionId } = event;\n      console.log(`Worker received task: Parse ${sessionId}`);\n      // Use Worker Thread to prevent event loop blocking\n      const workerPath = path_1.default.join(\n        __dirname,\n        './workers/pcap.worker.js',\n      );\n      // Note: In dev TS environment, we might need to point to the .ts file via ts-node or similar if not built.\n      // But Docker runs 'npm run build' so it runs JS.\n      // However, path.join(__dirname, './workers/pcap.worker.js') would be:\n      // dist/workers/workers/pcap.worker.js? No.\n      // __dirname in dist/workers/pcapWorker.js is .../dist/workers.\n      // So ./pcap.worker.js is correct if both are in same folder.\n      // checking where pcap.worker.ts will be output: dist/workers/pcap.worker.js.\n      // So path.join(__dirname, 'pcap.worker.js') is correct.\n      const worker = new worker_threads_1.Worker(\n        path_1.default.join(__dirname, 'pcap.worker.js'),\n        {\n          workerData: { filePath, sessionId },\n        },\n      );\n      worker.on('message', (msg) => {\n        if (msg.type === 'progress') {\n          if (analysis_1.activeSessions[msg.sessionId]) {\n            analysis_1.activeSessions[msg.sessionId].progress = msg.count;\n            analysis_1.activeSessions[msg.sessionId].summary.packetCount =\n              msg.count;\n          }\n        } else if (msg.type === 'complete') {\n          console.log(`Worker finished task: Parse ${msg.sessionId}`);\n          if (analysis_1.activeSessions[msg.sessionId]) {\n            analysis_1.activeSessions[msg.sessionId].status = 'complete';\n          }\n        } else if (msg.type === 'error') {\n          console.error(\n            `Worker failed task ${msg.sessionId || 'unknown'}:`,\n            msg.error,\n          );\n          if (msg.sessionId && analysis_1.activeSessions[msg.sessionId]) {\n            analysis_1.activeSessions[msg.sessionId].error = msg.error;\n            analysis_1.activeSessions[msg.sessionId].status = 'error';\n          }\n        }\n      });\n      worker.on('error', (err) => {\n        console.error('Worker thread error:', err);\n      });\n      worker.on('exit', (code) => {\n        if (code !== 0) {\n          console.error(`Worker stopped with exit code ${code}`);\n        }\n      });\n    },\n  );\n};\nexports.startPcapWorker = startPcapWorker;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/scripts/verify-cap.ts","messages":[{"ruleId":"@typescript-eslint/triple-slash-reference","severity":2,"message":"Do not use a triple slash reference for ./types/cap.d.ts, use `import` style instead.","line":1,"column":1,"nodeType":"Line","messageId":"tripleSlashReference","endLine":1,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/// <reference path=\"./types/cap.d.ts\" />\nimport { Cap } from 'cap';\n\nconsole.log('Verifying Cap installation...');\ntry {\n  const devices = Cap.deviceList();\n  console.log('Cap loaded successfully!');\n  console.log(`Found ${devices.length} network interfaces.`);\n  devices.forEach((d: any) =>\n    console.log(` - ${d.name} (${d.addresses.length} addresses)`),\n  );\n} catch (err) {\n  console.error('Failed to load Cap or list devices:', err);\n  process.exit(1);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/controllers/AuthController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/controllers/CaptureController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'promiscuous' is assigned a value but never used.","line":9,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":18},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":150,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":150,"endColumn":29},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":151,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":151,"endColumn":33}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { CaptureService } from '../services/CaptureService';\nimport { StorageService } from '../services/StorageService';\n\nexport class CaptureController {\n  public static async startCapture(req: Request, res: Response): Promise<void> {\n    const {\n      interface: interfaceName,\n      promiscuous,\n      filter,\n      sizeLimit,\n    } = req.body;\n\n    if (!interfaceName) {\n      res.status(400).json({ error: 'Interface name is required' });\n      return;\n    }\n\n    try {\n      const session = await CaptureService.startCapture(\n        interfaceName,\n        filter,\n        sizeLimit ? Number(sizeLimit) : 0,\n      );\n      res.status(201).json({\n        message: 'Capture started',\n        data: {\n          id: session.id,\n          output: session.outputFilePath,\n        },\n      });\n    } catch (error: any) {\n      console.error('Start capture error details:', error);\n      if (error.message.includes('already running')) {\n        res.status(409).json({ error: error.message });\n      } else if (\n        error.message.toLowerCase().includes('syntax') ||\n        error.message.toLowerCase().includes('expression')\n      ) {\n        res.status(400).json({ error: `Invalid BPF filter: ${error.message}` });\n      } else {\n        res.status(500).json({ error: 'Failed to start capture' });\n      }\n    }\n  }\n\n  public static stopCapture(req: Request, res: Response): void {\n    const { interface: interfaceName } = req.body;\n\n    if (!interfaceName) {\n      res.status(400).json({ error: 'Interface name is required' });\n      return;\n    }\n\n    try {\n      const info = CaptureService.stopCapture(interfaceName);\n      res.status(200).json({\n        message: 'Capture stopped',\n        data: info,\n      });\n    } catch (error: any) {\n      console.error('Stop capture error:', error);\n      if (error.message.includes('No active capture')) {\n        res.status(404).json({ error: error.message });\n      } else {\n        res.status(500).json({ error: 'Failed to stop capture' });\n      }\n    }\n  }\n\n  public static pauseCapture(req: Request, res: Response): void {\n    const { interface: interfaceName } = req.body;\n\n    if (!interfaceName) {\n      res.status(400).json({ error: 'Interface name is required' });\n      return;\n    }\n\n    try {\n      CaptureService.pauseCapture(interfaceName);\n      res.status(200).json({ message: 'Capture paused' });\n    } catch (error: any) {\n      console.error('Pause capture error:', error);\n      if (error.message.includes('No active capture')) {\n        res.status(404).json({ error: error.message });\n      } else {\n        res.status(500).json({ error: 'Failed to pause capture' });\n      }\n    }\n  }\n\n  public static resumeCapture(req: Request, res: Response): void {\n    const { interface: interfaceName } = req.body;\n\n    if (!interfaceName) {\n      res.status(400).json({ error: 'Interface name is required' });\n      return;\n    }\n\n    try {\n      CaptureService.resumeCapture(interfaceName);\n      res.status(200).json({ message: 'Capture resumed' });\n    } catch (error: any) {\n      console.error('Resume capture error:', error);\n      if (error.message.includes('No active capture')) {\n        res.status(404).json({ error: error.message });\n      } else {\n        res.status(500).json({ error: 'Failed to resume capture' });\n      }\n    }\n  }\n\n  public static getStats(req: Request, res: Response): void {\n    const { interface: interfaceName } = req.query;\n\n    if (!interfaceName || typeof interfaceName !== 'string') {\n      res\n        .status(400)\n        .json({ error: 'Interface name is required (query param: interface)' });\n      return;\n    }\n\n    try {\n      const stats = CaptureService.getCaptureStats(interfaceName);\n      res.status(200).json(stats);\n    } catch (error: any) {\n      if (error.message.includes('No active capture')) {\n        res.status(404).json({ error: error.message });\n      } else {\n        console.error('Get stats error:', error);\n        res.status(500).json({ error: 'Failed to get capture stats' });\n      }\n    }\n  }\n\n  public static downloadCapture(req: Request, res: Response): void {\n    const { id } = req.params;\n\n    if (!id) {\n      res.status(400).json({ error: 'Capture ID is required' });\n      return;\n    }\n\n    // Basic path traversal prevention\n    if (id.includes('..') || id.includes('/') || id.includes('\\\\')) {\n      res.status(400).json({ error: 'Invalid capture ID' });\n      return;\n    }\n\n    const fs = require('fs');\n    const path = require('path');\n\n    // Allow ID to be just UUID or filename\n    let filename = id;\n    if (!filename.endsWith('.pcap')) {\n      filename += '.pcap';\n    }\n\n    const filePath = path.join(StorageService.getCaptureDir(), filename);\n\n    if (!fs.existsSync(filePath)) {\n      res.status(404).json({ error: 'Capture file not found' });\n      return;\n    }\n\n    res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n    res.setHeader('Content-Type', 'application/vnd.tcpdump.pcap');\n\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n\n    fileStream.on('error', (error: any) => {\n      console.error('Error streaming file:', error);\n      if (!res.headersSent) {\n        res.status(500).json({ error: 'Failed to download file' });\n      }\n    });\n  }\n\n  public static listSessions(req: Request, res: Response): void {\n    try {\n      const sessions = CaptureService.getSessions();\n      res.json(sessions);\n    } catch (error) {\n      // Error handler should catch this ideally if logic fails, but for now manual try/catch or just let it bubble\n      // Since method is static and simple, just res.json\n      console.error('List sessions error', error);\n      res.status(500).json({ error: 'Failed to list sessions' });\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/controllers/InterfaceController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/controllers/MetaController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/controllers/SessionController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/db/Database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/middleware/authMiddleware.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":7,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":11,"endColumn":4},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":38,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-key-change-in-prod';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: any;\n    }\n  }\n}\n\nexport const authMiddleware = (\n  req: Request,\n  res: Response,\n  next: NextFunction,\n) => {\n  // Check for Authorization header\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader) {\n    res.status(401).json({ error: 'Authentication required' });\n    return;\n  }\n\n  const token = authHeader.split(' ')[1]; // Bearer <token>\n\n  if (!token) {\n    res.status(401).json({ error: 'Authentication required' });\n    return;\n  }\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/middleware/errorHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":7}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\n\nexport interface AppError extends Error {\n  statusCode?: number;\n  code?: string | number;\n}\n\nexport const errorHandler = (\n  err: AppError,\n  req: Request,\n  res: Response,\n  next: NextFunction,\n) => {\n  // Log the error\n  console.error('API Error:', {\n    message: err.message,\n    stack: err.stack,\n    path: req.path,\n    method: req.method,\n  });\n\n  const statusCode = err.statusCode || 500;\n  const message = err.message || 'Internal Server Error';\n\n  res.status(statusCode).json({\n    error: message,\n    code: err.code,\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/repositories/SessionRepository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/routes/analysis.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parsePcapFile' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport multer from 'multer';\nimport path from 'path';\nimport { parsePcapFile } from '../services/pcapService';\n\nexport const analysisRouter = express.Router();\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    // Save to server/uploads\n    cb(null, path.join(__dirname, '../../uploads'));\n  },\n  filename: (req, file, cb) => {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);\n    cb(\n      null,\n      file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname),\n    );\n  },\n});\n\nconst upload = multer({ storage: storage });\n\nimport { kafkaService } from '../services/kafkaService';\nimport { elasticService } from '../services/elasticService';\n\n// Store active parsing sessions (in-memory for MVP status tracking, full data in ES)\nexport const activeSessions: Record<string, any> = {};\n\nanalysisRouter.post('/upload', upload.single('pcap'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).json({ error: 'No file uploaded' });\n  }\n\n  const filePath = req.file.path;\n  const sessionId = req.file.filename;\n\n  console.log(`File uploaded: ${filePath}, Session: ${sessionId}`);\n\n  // Initialize session state\n  activeSessions[sessionId] = {\n    status: 'processing',\n    progress: 0,\n    error: null,\n    summary: {\n      packetCount: 0,\n      totalBytes: 0,\n    },\n  };\n\n  // Offload to Kafka Worker\n  try {\n    await kafkaService.produce('pcap-upload', {\n      filePath,\n      sessionId,\n    });\n\n    // Simulating the worker picking it up:\n    // In a real microservice, a separate worker process would consume this.\n    // For this MVP monolith, we'll start the processing logic \"as if\" triggered by Kafka if we wanted,\n    // OR we can actually implement the Consumer in this same process to read it back.\n    // Let's implement the Consumer listener in pcapService or index.ts to actually do the work.\n  } catch (err: any) {\n    console.error(`Failed to queue pcap for session ${sessionId}:`, err);\n    return res\n      .status(500)\n      .json({ error: 'Failed to queue file for processing' });\n  }\n\n  res.json({\n    sessionId,\n    status: 'processing',\n    originalName: req.file.originalname,\n    size: req.file.size,\n  });\n});\n\nanalysisRouter.get('/analysis/:sessionId/status', (req, res) => {\n  const { sessionId } = req.params;\n  const session = activeSessions[sessionId];\n\n  // If session is not in memory (restart?), check ES for ANY packet to see if it exists?\n  // For MVP, keep using memory for status.\n\n  if (!session) {\n    return res.status(404).json({ error: 'Session not found' });\n  }\n\n  res.json({\n    status: session.status,\n    progress: session.progress,\n    packetCount: session.summary.packetCount,\n    error: session.error,\n  });\n});\n\nanalysisRouter.get('/analysis/:sessionId/results', async (req, res) => {\n  const { sessionId } = req.params;\n  // Pagination params\n  const from = parseInt(req.query.from as string) || 0;\n  const size = parseInt(req.query.size as string) || 100;\n\n  // Check if processing is done (optional, or just return what we have)\n  // const session = activeSessions[sessionId];\n\n  try {\n    const hits = await elasticService.searchPackets(sessionId, size, from);\n\n    // Map ES hits to clean Packet objects\n    const packets = hits.hits.map((hit: any) => hit._source);\n\n    res.json({\n      sessionId,\n      status: activeSessions[sessionId]?.status || 'unknown',\n      summary: activeSessions[sessionId]?.summary || {},\n      packets: packets,\n      total: hits.total.value,\n    });\n  } catch (e) {\n    console.error('Failed to fetch results from ES', e);\n    res.status(500).json({ error: 'Failed to fetch results' });\n  }\n});\n\nanalysisRouter.get('/analysis/:sessionId/stats', async (req, res) => {\n  const { sessionId } = req.params;\n\n  try {\n    const stats = await elasticService.getDashboardStats(sessionId);\n    if (!stats) {\n      return res.status(503).json({ error: 'Elasticsearch not connected' });\n    }\n    res.json(stats);\n  } catch (e) {\n    console.error('Failed to fetch stats from ES', e);\n    res.status(500).json({ error: 'Failed to fetch stats' });\n  }\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/routes/capture.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/routes/iocs.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":11,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":37,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport { iocService } from '../services/iocService';\n\nconst router = express.Router();\n\n// GET /api/iocs\nrouter.get('/', (req, res) => {\n  try {\n    const iocs = iocService.getIocs();\n    res.json(iocs);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch IOCs' });\n  }\n});\n\n// POST /api/iocs\nrouter.post('/', (req, res) => {\n  try {\n    const { type, value, severity, description } = req.body;\n    if (!type || !value || !severity) {\n      return res.status(400).json({ error: 'Missing required fields' });\n    }\n    const newIoc = iocService.addIoc({ type, value, severity, description });\n    res.status(201).json(newIoc);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Failed to add IOC' });\n  }\n});\n\n// DELETE /api/iocs/:id\nrouter.delete('/:id', (req, res) => {\n  try {\n    const { id } = req.params;\n    iocService.removeIoc(id);\n    res.status(200).json({ message: 'IOC removed' });\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to remove IOC' });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/routes/sessions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/routes/yara.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":16,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport { yaraService } from '../services/yaraService';\n\nconst router = express.Router();\n\n// GET /api/yara\nrouter.get('/', (req, res) => {\n  try {\n    const rules = yaraService.getRules().map((r, index) => ({\n      id: String(index), // simple index ID for now\n      name: r.name,\n      content: r.source,\n      enabled: true,\n    }));\n    res.json(rules);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch rules' });\n  }\n});\n\n// POST /api/yara\nrouter.post('/', async (req, res) => {\n  try {\n    const { name, content } = req.body;\n    if (!name || !content) {\n      return res.status(400).json({ error: 'Missing name or content' });\n    }\n    await yaraService.addRule(name, content);\n    res.status(201).json({ message: 'Rule added' });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Failed to add rule' });\n  }\n});\n\n// DELETE /api/yara/:id\n// Since we used index as ID effectively (or need logic in service):\n// yaraService currently doesn't have delete by ID, and stores simple array.\n// For MVP, implementing delete might require updating YaraService to assign IDs.\n// Skipping delete for now or will implement if time permits.\n// User requested \"work with server side\", editing rules on server is expected.\n// We should probably update YaraService to use IDs.\n// But for now, returning 501.\nrouter.delete('/:id', (req, res) => {\n  res.status(501).json({ error: 'Delete not implemented on server yet' });\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/CaptureService.ts","messages":[{"ruleId":"@typescript-eslint/triple-slash-reference","severity":2,"message":"Do not use a triple slash reference for ../types/cap.d.ts, use `import` style instead.","line":1,"column":1,"nodeType":"Line","messageId":"tripleSlashReference","endLine":1,"endColumn":43}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/// <reference path=\"../types/cap.d.ts\" />\nimport { Cap } from 'cap';\nimport { CaptureSession } from './CaptureSession';\n\nexport interface NetworkInterface {\n  name: string;\n  addresses: {\n    addr?: string;\n    netmask?: string;\n    broadaddr?: string;\n  }[];\n  description?: string;\n}\n\nexport class CaptureService {\n  private static activeSessions: Map<string, CaptureSession> = new Map();\n\n  public static getInterfaces(): NetworkInterface[] {\n    try {\n      const devices = Cap.deviceList();\n      return devices.map((device: any) => ({\n        name: device.name,\n        addresses: device.addresses,\n        description: device.description || '',\n      }));\n    } catch (error) {\n      console.error('Error fetching interfaces:', error);\n      throw new Error('Failed to retrieve network interfaces');\n    }\n  }\n\n  public static async startCapture(\n    interfaceName: string,\n    filter?: string,\n    sizeLimit?: number,\n  ): Promise<CaptureSession> {\n    if (this.activeSessions.has(interfaceName)) {\n      throw new Error(`Capture already running on ${interfaceName}`);\n    }\n\n    const session = new CaptureSession(interfaceName);\n    // The original start method had promiscuous: boolean = false.\n    // Since the new signature removes it, we'll assume it's handled internally by CaptureSession or defaults to false.\n    // The original filter and sizeLimit had default values, now they are optional.\n    // We pass them as they are, letting CaptureSession handle undefined values if necessary.\n    session.start(false, filter || '', sizeLimit || 0); // Assuming promiscuous defaults to false\n    this.activeSessions.set(interfaceName, session);\n\n    return session;\n  }\n\n  public static stopCapture(interfaceName: string): {\n    packetCount: number;\n    output: string;\n  } {\n    const session = this.activeSessions.get(interfaceName);\n    if (!session) {\n      throw new Error(`No active capture on ${interfaceName}`);\n    }\n\n    session.stop();\n    this.activeSessions.delete(interfaceName);\n\n    return {\n      packetCount: session.packetCount,\n      output: session.outputFilePath,\n    };\n  }\n\n  public static pauseCapture(interfaceName: string): void {\n    const session = this.activeSessions.get(interfaceName);\n    if (!session) {\n      throw new Error(`No active capture on ${interfaceName}`);\n    }\n    session.pause();\n  }\n\n  public static resumeCapture(interfaceName: string): void {\n    const session = this.activeSessions.get(interfaceName);\n    if (!session) {\n      throw new Error(`No active capture on ${interfaceName}`);\n    }\n    session.resume();\n  }\n\n  public static getCaptureStats(interfaceName: string): any {\n    const session = this.activeSessions.get(interfaceName);\n    if (!session) {\n      throw new Error(`No active capture on ${interfaceName}`);\n    }\n    return session.getStats();\n  }\n\n  public static getSessions(): any[] {\n    const sessions: any[] = [];\n    this.activeSessions.forEach((session) => {\n      sessions.push({\n        interface: session.interfaceName,\n        ...session.getStats(),\n      });\n    });\n    return sessions;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/CaptureSession.ts","messages":[{"ruleId":"@typescript-eslint/triple-slash-reference","severity":2,"message":"Do not use a triple slash reference for ../types/cap.d.ts, use `import` style instead.","line":1,"column":1,"nodeType":"Line","messageId":"tripleSlashReference","endLine":1,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'promiscuous' is assigned a value but never used.","line":49,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'trunc' is defined but never used.","line":81,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":109,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":109,"endColumn":23},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":156,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":156,"endColumn":29}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/// <reference path=\"../types/cap.d.ts\" />\nimport { Cap } from 'cap';\nimport path from 'path';\nimport { PcapWriter } from '../utils/PcapWriter';\nimport { StorageService } from './StorageService';\nimport { sessionRepository } from '../repositories/SessionRepository';\nimport { PacketParser } from '../utils/PacketParser';\nimport { WebSocketService } from './WebSocketService';\nimport { WSMessageType } from '../types/WebSocketMessages';\n\nexport class CaptureSession {\n  public readonly id: string;\n  public readonly interfaceName: string;\n  public readonly startTime: number;\n  public packetCount: number = 0;\n\n  private cap: Cap;\n  private writer: PcapWriter | null = null;\n  private buffer: Buffer;\n  private running: boolean = false;\n  private paused: boolean = false;\n  private bytesWritten: number = 0;\n  private sizeLimitBytes: number = 0;\n  private diskCheckInterval: NodeJS.Timeout | null = null;\n  public readonly outputFilePath: string;\n\n  constructor(interfaceName: string) {\n    this.id = `cap_${Date.now()}_${interfaceName}`;\n    this.interfaceName = interfaceName;\n    this.startTime = Date.now();\n    this.outputFilePath = StorageService.generatePath(interfaceName);\n    this.cap = new Cap();\n    this.buffer = Buffer.alloc(65535);\n\n    // Create initial DB record\n    sessionRepository.create({\n      id: this.id,\n      interfaceName: this.interfaceName,\n      startTime: this.startTime,\n      endTime: null,\n      status: 'running',\n      packetCount: 0,\n      sizeBytes: 0,\n      outputFilePath: this.outputFilePath,\n    });\n  }\n\n  public start(\n    promiscuous: boolean = false,\n    filter: string = '',\n    sizeLimitMB: number = 0,\n  ) {\n    // On macOS, cap.open() requires the interface NAME (e.g., 'en0'), not the IP address\n    const target = this.interfaceName;\n    console.log(`CaptureSession: starting capture on interface '${target}'`);\n\n    if (sizeLimitMB > 0) {\n      this.sizeLimitBytes = sizeLimitMB * 1024 * 1024;\n    }\n\n    try {\n      const linkType = this.cap.open(\n        target,\n        filter,\n        10 * 1024 * 1024,\n        this.buffer,\n      );\n      // setMinBytes not available in all cap versions, removed\n\n      // Directory handled by StorageService\n\n      this.writer = new PcapWriter(\n        this.outputFilePath,\n        typeof linkType === 'string' ? 1 : (linkType as unknown as number),\n      ); // linkType from cap.open is string 'ETH' etc or number?\n      // node-cap documentation says it returns the link type (LINKTYPE_...) which is an integer usually.\n      // Let's cast it safely. If it returns 'ETHERNET' string, we need to map it.\n      // For now assume it returns the integer linktype as expected by pcap.\n      this.bytesWritten = 24; // Global header\n\n      this.cap.on('packet', (nBytes: number, trunc: boolean) => {\n        if (this.running && !this.paused && this.writer) {\n          this.packetCount++;\n          // nBytes is number of bytes received\n          // The data is in this.buffer.slice(0, nBytes)\n          const data = this.buffer.slice(0, nBytes);\n          this.writer.writePacket(data);\n          this.bytesWritten += 16 + data.length; // 16 bytes packet header + payload\n\n          if (\n            this.sizeLimitBytes > 0 &&\n            this.bytesWritten >= this.sizeLimitBytes\n          ) {\n            console.log(\n              `Size limit of ${this.sizeLimitBytes} bytes reached. Stopping capture.`,\n            );\n            this.stop();\n          }\n\n          // Parse and broadcast live packet\n          try {\n            const packetData = PacketParser.parse(data, Date.now());\n            if (packetData) {\n              WebSocketService.broadcast({\n                type: WSMessageType.PACKET,\n                data: packetData,\n              });\n            }\n          } catch (err) {\n            // Silent fail for broadcast to not stop capture\n          }\n        }\n      });\n\n      this.running = true;\n      this.paused = false;\n\n      // Start disk space check interval (every 5 seconds)\n      this.startDiskCheck();\n\n      console.log(\n        `Started capture on ${this.interfaceName} (Target: ${target}). Output: ${this.outputFilePath}`,\n      );\n    } catch (e) {\n      console.error(`Failed to start capture on ${this.interfaceName}`, e);\n      throw e;\n    }\n  }\n\n  public stop() {\n    if (this.running) {\n      this.running = false;\n      this.paused = false;\n      this.cap.close();\n      this.writer?.close();\n      if (this.diskCheckInterval) {\n        clearInterval(this.diskCheckInterval);\n        this.diskCheckInterval = null;\n      }\n\n      // Update DB record\n      sessionRepository.update(this.id, {\n        endTime: Date.now(),\n        status: 'stopped',\n        packetCount: this.packetCount,\n        sizeBytes: this.bytesWritten,\n      });\n\n      console.log(\n        `Stopped capture on ${this.interfaceName}. captured ${this.packetCount} packets.`,\n      );\n    }\n  }\n\n  private startDiskCheck() {\n    const fs = require('fs');\n    this.diskCheckInterval = setInterval(() => {\n      if (!this.running) return;\n\n      try {\n        // Check free space on the volume where captures are stored\n        // fs.statfs is available in Node 18+\n        if (fs.statfs) {\n          fs.statfs(\n            path.dirname(this.outputFilePath),\n            (err: any, stats: any) => {\n              if (err) {\n                console.error('Error checking disk space:', err);\n                return;\n              }\n              // stats.bavail: free blocks available to non-super user, stats.bsize: block size\n              const freeBytes = stats.bavail * stats.bsize;\n              // 100MB critical threshold\n              if (freeBytes < 100 * 1024 * 1024) {\n                console.warn(\n                  `Critical disk space (${Math.round(freeBytes / 1024 / 1024)}MB free). Stopping capture.`,\n                );\n                this.stop();\n              }\n            },\n          );\n        }\n      } catch (err) {\n        console.error('Disk check failed', err);\n      }\n    }, 5000);\n  }\n\n  public pause() {\n    if (this.running) {\n      this.paused = true;\n      console.log(`Paused capture on ${this.interfaceName}`);\n    }\n  }\n\n  public resume() {\n    if (this.running && this.paused) {\n      this.paused = false;\n      console.log(`Resumed capture on ${this.interfaceName}`);\n    }\n  }\n\n  public isActive(): boolean {\n    return this.running;\n  }\n\n  public isPaused(): boolean {\n    return this.paused;\n  }\n\n  public getStats() {\n    return {\n      captured: this.packetCount,\n      dropped: 0, // Not available directly from cap event loop easily without implementing stats call\n      fileSize: this.bytesWritten,\n      duration: Date.now() - this.startTime,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/CleanupService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/StorageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/WebSocketService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'decoded' is assigned a value but never used.","line":52,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":52,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":58,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":65,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Server } from 'http';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { IncomingMessage } from 'http';\nimport jwt from 'jsonwebtoken';\nimport {\n  WSServerMessage,\n  WSMessageType,\n  PacketFilter,\n  PacketData,\n  PacketMessage,\n} from '../types/WebSocketMessages';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-key-change-in-prod';\n\nexport class WebSocketService {\n  private static wss: WebSocketServer;\n  private static clientFilters: Map<WebSocket, PacketFilter> = new Map();\n\n  public static init(server: Server): void {\n    this.wss = new WebSocketServer({ noServer: true });\n\n    server.on('upgrade', (request, socket, head) => {\n      this.handleUpgrade(request, socket, head);\n    });\n\n    this.wss.on('connection', (ws, req) => {\n      this.handleConnection(ws, req);\n    });\n\n    console.log('WebSocket server initialized.');\n  }\n\n  private static handleUpgrade(\n    request: IncomingMessage,\n    socket: any,\n    head: Buffer,\n  ): void {\n    // Use WHATWG URL API instead of deprecated url.parse()\n    const reqUrl = new URL(\n      request.url || '',\n      `http://${request.headers.host || 'localhost'}`,\n    );\n    const token = reqUrl.searchParams.get('token');\n\n    if (!token) {\n      socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n      socket.destroy();\n      return;\n    }\n\n    try {\n      const decoded = jwt.verify(token, JWT_SECRET);\n      // If verification succeeds, we're good.\n\n      this.wss.handleUpgrade(request, socket, head, (ws) => {\n        this.wss.emit('connection', ws, request);\n      });\n    } catch (err) {\n      socket.write('HTTP/1.1 403 Forbidden\\r\\n\\r\\n');\n      socket.destroy();\n      return;\n    }\n  }\n\n  private static handleConnection(ws: WebSocket, req: IncomingMessage): void {\n    console.log('New WebSocket connection established.');\n\n    ws.on('message', (message) => {\n      try {\n        const msg = JSON.parse(message.toString());\n        if (msg.type === WSMessageType.UPDATE_FILTER) {\n          this.clientFilters.set(ws, msg.filters || {});\n          console.log('Filter updated for client:', msg.filters);\n        }\n      } catch (e) {\n        console.error('Failed to parse message:', e);\n      }\n    });\n\n    ws.on('close', () => {\n      this.clientFilters.delete(ws);\n      console.log('WebSocket connection closed.');\n    });\n  }\n\n  private static matchesFilter(\n    packet: PacketData,\n    filter: PacketFilter,\n  ): boolean {\n    if (\n      filter.protocol &&\n      packet.protocol.toLowerCase() !== filter.protocol.toLowerCase()\n    ) {\n      return false;\n    }\n    if (filter.sourceIP && packet.sourceIP !== filter.sourceIP) {\n      return false;\n    }\n    if (filter.destinationIP && packet.destinationIP !== filter.destinationIP) {\n      return false;\n    }\n    if (\n      filter.port &&\n      packet.sourcePort !== filter.port &&\n      packet.destinationPort !== filter.port\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  public static broadcast(message: WSServerMessage): void {\n    if (!this.wss) return;\n\n    this.wss.clients.forEach((client) => {\n      if (client.readyState === WebSocket.OPEN) {\n        // Apply per-client filter for PACKET messages\n        if (message.type === WSMessageType.PACKET) {\n          const filter = this.clientFilters.get(client);\n          if (filter && Object.keys(filter).length > 0) {\n            if (!this.matchesFilter((message as PacketMessage).data, filter)) {\n              return; // Skip this client\n            }\n          }\n        }\n        client.send(JSON.stringify(message));\n      }\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/elasticService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/iocService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/kafkaService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/pcapService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fs' is defined but never used.","line":1,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":10},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":2,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":2,"endColumn":14,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[21,34],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":69,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs';\n// @ts-ignore\nimport pcapParser from 'pcap-parser';\nimport geoip from 'geoip-lite';\n// import { activeSessions } from '../routes/analysis'; // Decoupled for Worker Thread\nimport {\n  extractStringsFromBuffer,\n  ExtractedString,\n} from '../utils/stringExtractor';\nimport { fileExtractor, FileReference } from '../utils/fileExtractor';\nimport { runThreatDetection, ThreatAlert } from '../utils/threatDetection';\nimport { iocService } from './iocService';\nimport { yaraService } from './yaraService';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface PacketMetadata {\n  id: number;\n  timestamp: number;\n  sourceIp: string | null;\n  destIp: string | null;\n  protocol: string;\n  length: number;\n  info: string;\n  raw?: string;\n  strings?: ExtractedString[];\n  fileReferences?: FileReference[];\n  threats?: ThreatAlert[];\n  geoip?: { country: string };\n}\n\nimport { elasticService } from './elasticService';\n\nexport const parsePcapFile = (\n  filePath: string,\n  sessionId: string,\n  onProgress?: (count: number) => void,\n): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    let packetCount = 0;\n    let batch: any[] = [];\n    const BATCH_SIZE = 500;\n\n    // Create parser\n    console.log(`[pcapService] Starting parse for ${filePath}`);\n    const parser = pcapParser.parse(filePath);\n\n    parser.on('packet', async (packet: any) => {\n      packetCount++;\n      if (packetCount % 100 === 0)\n        console.log(`[pcapService] Parsed ${packetCount} packets...`);\n\n      const data = packet.data; // This is a Buffer\n      const offset = 14;\n      let srcIp: string | null = null;\n      let dstIp: string | null = null;\n      let protocol = 'Unknown';\n\n      try {\n        const etherType = data.readUInt16BE(12);\n        if (etherType === 0x0800) {\n          srcIp = `${data[offset + 12]}.${data[offset + 13]}.${data[offset + 14]}.${data[offset + 15]}`;\n          dstIp = `${data[offset + 16]}.${data[offset + 17]}.${data[offset + 18]}.${data[offset + 19]}`;\n          const proto = data[offset + 9];\n          if (proto === 6) protocol = 'TCP';\n          else if (proto === 17) protocol = 'UDP';\n          else if (proto === 1) protocol = 'ICMP';\n          else protocol = `IP(${proto})`;\n        }\n      } catch (e) {}\n\n      // Extended Analysis\n      const packetIdString = `${sessionId}-${packetCount}`;\n      // Pass minimal packet info needed for detection context\n      const packetInfoForDetection = {\n        id: packetIdString,\n        timestamp: new Date(\n          packet.header.timestampSeconds * 1000 +\n            packet.header.timestampMicroseconds / 1000,\n        ),\n        sourceIp: srcIp,\n        destIp: dstIp,\n        sourcePort: 0, // Need full parsing for ports, skipping for now\n        destPort: 0,\n      };\n\n      // GeoIP Lookup\n      let geoInfo = undefined;\n      if (srcIp) {\n        const geo = geoip.lookup(srcIp);\n        if (geo && geo.country) {\n          geoInfo = { country: geo.country };\n        }\n      }\n\n      // Extract Strings\n      const strings = extractStringsFromBuffer(data, packetIdString);\n\n      // Extract Files\n      const fileReferences = fileExtractor.detectFileReferences(\n        {\n          ...packetInfoForDetection,\n          protocol,\n          sourcePort: 0, // Placeholder\n          destPort: 0, // Placeholder\n        },\n        data,\n      );\n\n      // Detect Threats\n      const threats = runThreatDetection(packetInfoForDetection, data);\n\n      // IOC Check\n      const iocMatches = iocService.checkPacket(packetInfoForDetection);\n      iocMatches.forEach((ioc) => {\n        threats.push({\n          id: uuidv4(),\n          packetId: packetInfoForDetection.id, // Ensure ID is string\n          severity: ioc.severity,\n          type: `IOC Match - ${ioc.type.toUpperCase()}`,\n          description: `Detected IOC: ${ioc.value}. ${ioc.description || ''}`,\n          mitreAttack: [],\n          timestamp: packetInfoForDetection.timestamp.getTime(),\n          sourceIp: packetInfoForDetection.sourceIp,\n          destIp: packetInfoForDetection.destIp,\n          sourcePort: 0,\n          destPort: 0,\n        });\n      });\n\n      // YARA Scan\n      try {\n        const yaraMatches = await yaraService.scanPayload(data);\n        yaraMatches.forEach((match) => {\n          // Auto-extract IOC from Threat\n          if (packetInfoForDetection.sourceIp) {\n            iocService.addIocIfNotExists({\n              type: 'ip',\n              value: packetInfoForDetection.sourceIp,\n              severity: 'high',\n              description: `Auto-detected from YARA Rule: ${match.rule}`,\n            });\n          }\n\n          threats.push({\n            id: uuidv4(),\n            packetId: packetInfoForDetection.id,\n            severity: 'high', // YARA matches usually correspond to specific malware rules\n            type: 'YARA Match',\n            description: `Rule: ${match.rule}`,\n            mitreAttack: [],\n            timestamp: packetInfoForDetection.timestamp.getTime(),\n            sourceIp: packetInfoForDetection.sourceIp,\n            destIp: packetInfoForDetection.destIp,\n            sourcePort: 0,\n            destPort: 0,\n          });\n        });\n      } catch (e) {\n        console.error(`YARA scan failed for packet ${packetCount}`, e);\n      }\n\n      const meta: any = {\n        sessionId,\n        timestamp: packetInfoForDetection.timestamp,\n        sourceIp: srcIp,\n        destIp: dstIp,\n        protocol: protocol,\n        length: packet.header.capturedLength,\n        info: `${protocol} Packet`,\n        raw: data.toString('base64'),\n        strings,\n        fileReferences,\n        threats,\n        geoip: geoInfo,\n      };\n\n      batch.push(meta);\n\n      if (batch.length >= BATCH_SIZE) {\n        const flushBatch = [...batch];\n        batch = [];\n        elasticService\n          .bulkIndexPackets(flushBatch)\n          .catch((e) => console.error('Index error', e));\n\n        if (onProgress) {\n          onProgress(packetCount);\n        }\n      }\n    });\n\n    parser.on('end', async () => {\n      console.log(`[pcapService] Parsing ended. Total packets: ${packetCount}`);\n      if (batch.length > 0) {\n        await elasticService.bulkIndexPackets(batch);\n      }\n      // Completion handled by caller (resolve)\n      resolve();\n    });\n\n    parser.on('error', (err: any) => {\n      console.error(`[pcapService] Parser Error:`, err);\n      reject(err);\n    });\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/services/yaraService.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":1,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":1,"endColumn":14,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[0,13],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":108,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":119,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-ignore\nimport YARA from 'libyara-wasm';\nimport fs from 'fs';\nimport path from 'path';\n\nexport interface YaraMatch {\n  rule: string;\n  description?: string;\n  tags: string[];\n  matches: { offset: number; length: number; data?: string }[];\n}\n\nexport class YaraService {\n  private static instance: YaraService;\n  private yaraInstance: any = null;\n  private rules: any[] = []; // Store compiled rules? Or source?\n  // libyara-wasm usually compiles a source string into a scanner/module.\n  // We might need to keep the \"scanner\" state.\n\n  // Simple in-memory storage for rule sources for now\n  private ruleSources: { name: string; source: string }[] = [];\n  private scanner: any = null;\n  private initialized: boolean = false;\n\n  private readonly RULES_FILE = path.join(\n    process.cwd(),\n    'data',\n    'yara_rules.json',\n  );\n\n  private constructor() {\n    this.loadStoredRules();\n  }\n\n  public static getInstance(): YaraService {\n    if (!YaraService.instance) {\n      YaraService.instance = new YaraService();\n    }\n    return YaraService.instance;\n  }\n\n  public async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Initialize WASM\n      this.yaraInstance = await YARA();\n      this.initialized = true;\n      console.log('YARA WASM initialized');\n\n      // Compile existing rules\n      await this.compileRules();\n    } catch (error) {\n      console.error('Failed to initialize YARA:', error);\n    }\n  }\n\n  private loadStoredRules() {\n    try {\n      if (fs.existsSync(this.RULES_FILE)) {\n        this.ruleSources = JSON.parse(\n          fs.readFileSync(this.RULES_FILE, 'utf-8'),\n        );\n      } else {\n        const dir = path.dirname(this.RULES_FILE);\n        if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n        // Add a default rule for testing\n        // Add default rules for demo scenarios\n        this.ruleSources = [\n          {\n            name: 'SQLInjection_Classic',\n            source:\n              \"rule SQLInjection_Classic { strings: $a = \\\"OR '1'='1\\\" condition: $a }\",\n          },\n          {\n            name: 'SQLInjection_Union',\n            source:\n              'rule SQLInjection_Union { strings: $a = \"UNION SELECT\" nocase condition: $a }',\n          },\n          {\n            name: 'XSS_Attack',\n            source:\n              'rule XSS_Attack { strings: $a = \"<script>\" nocase condition: $a }',\n          },\n          {\n            name: 'Suspicious_JSON_Cmd',\n            source:\n              'rule Suspicious_JSON_Cmd { strings: $a = \"\\\\\"cmd\\\\\": \\\\\"exec\\\\\"\" condition: $a }',\n          },\n          {\n            name: 'Malicious_Site',\n            source:\n              'rule Malicious_Site { strings: $a = \"Host: malicious-site.com\" nocase condition: $a }',\n          },\n          {\n            name: 'Command_Injection_Eval',\n            source:\n              'rule Command_Injection_Eval { strings: $a = \"eval(document.cookie)\" condition: $a }',\n          },\n          {\n            name: 'Test_Rule_HTTP',\n            source:\n              'rule Test_Rule_HTTP { strings: $a = \"HTTP\" condition: $a }',\n          },\n        ];\n        this.saveRules();\n      }\n    } catch (e) {\n      this.ruleSources = [];\n    }\n  }\n\n  private saveRules() {\n    try {\n      fs.writeFileSync(\n        this.RULES_FILE,\n        JSON.stringify(this.ruleSources, null, 2),\n      );\n    } catch (e) {}\n  }\n\n  public async compileRules(): Promise<void> {\n    // No-op: libyara-wasm compiles during run\n  }\n\n  public async scanPayload(buffer: Buffer): Promise<YaraMatch[]> {\n    if (!this.yaraInstance) return [];\n\n    try {\n      // libyara-wasm expects a binary string (latin1) for the payload\n      // Efficiently build string from buffer\n      let payloadStr = '';\n      const chunkSize = 0x8000;\n      for (let i = 0; i < buffer.length; i += chunkSize) {\n        payloadStr += String.fromCharCode.apply(\n          null,\n          buffer.subarray(i, i + chunkSize) as unknown as number[],\n        );\n      }\n\n      const activeRules = this.ruleSources.map((r) => r.source).join('\\n');\n      if (!activeRules.trim()) return [];\n\n      const result = this.yaraInstance.run(payloadStr, activeRules);\n\n      const matches: YaraMatch[] = [];\n\n      if (result.matchedRules) {\n        for (let i = 0; i < result.matchedRules.size(); i++) {\n          const match = result.matchedRules.get(i);\n          const resolvedMatches: {\n            offset: number;\n            length: number;\n            data?: string;\n          }[] = [];\n\n          if (match.resolvedMatches) {\n            for (let j = 0; j < match.resolvedMatches.size(); j++) {\n              const rm = match.resolvedMatches.get(j);\n              resolvedMatches.push({\n                offset: rm.location,\n                length: rm.matchLength || rm.match_length,\n                data: rm.data,\n              });\n            }\n          }\n\n          matches.push({\n            rule: match.ruleName || match.rule_name,\n            tags: [], // Metadata/Tags extraction if needed\n            matches: resolvedMatches,\n          });\n        }\n      }\n\n      if (result.delete) result.delete();\n      return matches;\n    } catch (error) {\n      console.error('YARA Scan failed:', error);\n      return [];\n    }\n  }\n\n  public async addRule(name: string, source: string): Promise<void> {\n    this.ruleSources.push({ name, source });\n    this.saveRules();\n    await this.compileRules();\n  }\n\n  public getRules() {\n    return this.ruleSources;\n  }\n}\n\nexport const yaraService = YaraService.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/types/WebSocketMessages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/types/cap.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/utils/PacketParser.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'summary' is assigned a value but never used.","line":59,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":77,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PacketData } from '../types/WebSocketMessages';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport class PacketParser {\n  static parse(buffer: Buffer, timestamp: number): PacketData | null {\n    // Basic parsing for Ethernet II / IPv4\n    // TODO: Add support for IPv6, etc.\n\n    try {\n      // Ethernet Header (14 bytes)\n      // Destination MAC (6), Source MAC (6), EtherType (2)\n      const etherType = buffer.readUInt16BE(12);\n\n      let protocol = 'Unknown';\n      let sourceIP = 'Unknown';\n      let destinationIP = 'Unknown';\n      let sourcePort = 0;\n      let destinationPort = 0;\n      let summary = '';\n\n      // IPv4\n      if (etherType === 0x0800) {\n        const ipOffset = 14;\n        // Version + IHL\n        const verIhl = buffer[ipOffset];\n        const ihl = (verIhl & 0x0f) * 4; // Header length in bytes\n\n        // Protocol\n        const proto = buffer[ipOffset + 9];\n\n        // IPs\n        sourceIP = `${buffer[ipOffset + 12]}.${buffer[ipOffset + 13]}.${buffer[ipOffset + 14]}.${buffer[ipOffset + 15]}`;\n        destinationIP = `${buffer[ipOffset + 16]}.${buffer[ipOffset + 17]}.${buffer[ipOffset + 18]}.${buffer[ipOffset + 19]}`;\n\n        const transportOffset = ipOffset + ihl;\n\n        if (proto === 6) {\n          protocol = 'TCP';\n          sourcePort = buffer.readUInt16BE(transportOffset);\n          destinationPort = buffer.readUInt16BE(transportOffset + 2);\n        } else if (proto === 17) {\n          protocol = 'UDP';\n          sourcePort = buffer.readUInt16BE(transportOffset);\n          destinationPort = buffer.readUInt16BE(transportOffset + 2);\n        } else if (proto === 1) {\n          protocol = 'ICMP';\n        } else {\n          protocol = `IP(${proto})`;\n        }\n      } else if (etherType === 0x86dd) {\n        protocol = 'IPv6';\n        // IPv6 parsing placeholder\n      } else if (etherType === 0x0806) {\n        protocol = 'ARP';\n      } else {\n        protocol = `Eth(${etherType.toString(16)})`;\n      }\n\n      summary = `${protocol} ${sourceIP}:${sourcePort} -> ${destinationIP}:${destinationPort}`;\n\n      return {\n        id: uuidv4(),\n        timestamp,\n        protocol,\n        sourceIP,\n        destinationIP,\n        sourcePort,\n        destinationPort,\n        length: buffer.length,\n        summary: `${protocol} ${sourceIP}:${sourcePort} -> ${destinationIP}:${destinationPort}`,\n        severity: 'low', // Default severity\n        payload:\n          buffer.length > 2048\n            ? buffer.subarray(0, 2048).toString('base64')\n            : buffer.toString('base64'),\n      };\n    } catch (error) {\n      // console.error('Error parsing packet:', error);\n      return null;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/utils/PcapWriter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/utils/fileExtractor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'crypto' is defined but never used.","line":2,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { v4 as uuidv4 } from 'uuid';\nimport crypto from 'crypto';\n\nexport interface FileReference {\n  id: string;\n  filename?: string;\n  size: number;\n  mimeType: string;\n  sourcePacketId: string; // The ID of the packet where detection occurred\n  // data: Buffer; // For now we won't store the full file content in ES to save space, maybe just metadata?\n  // Actually, storing small files (<1MB) in ES as base64 is okay. For larger, we'd need a separate store (S3/Disk).\n  // Let's store up to a limit.\n  dataOffset?: number; // Where in the raw packet does it start?\n  sha256Hash?: string;\n  ftpDataPort?: number;\n  ftpTransferType?: 'STOR' | 'RETR';\n}\n\nexport class FileExtractor {\n  private static HTTP_FILE_CONTENT_TYPES = [\n    /^application\\//,\n    /^image\\//,\n    /^video\\//,\n    /^audio\\//,\n    /^font\\//,\n    /^text\\/(?!html|css|javascript|plain)/,\n  ];\n\n  private ftpControlToDataPort = new Map<string, number>();\n\n  private getControlKey(packet: any): string {\n    // packet.sourceIp / destIp are verified to be strings now or null.\n    // If null return empty\n    if (!packet.sourceIp || !packet.destIp) return '';\n\n    if (packet.destPort === 21)\n      return `${packet.sourceIp}:${packet.sourcePort}`;\n    if (packet.sourcePort === 21) return `${packet.destIp}:${packet.destPort}`;\n    return '';\n  }\n\n  private parseHttpHeaders(httpResponseString: string): Record<string, string> {\n    const headers: Record<string, string> = {};\n    const headerLines = httpResponseString.split('\\r\\n');\n    for (let i = 1; i < headerLines.length; i++) {\n      const line = headerLines[i];\n      if (line.trim() === '') break;\n      const parts = line.split(':');\n      if (parts.length > 1) {\n        const key = parts[0].trim().toLowerCase();\n        const value = parts.slice(1).join(':').trim();\n        headers[key] = value;\n      }\n    }\n    return headers;\n  }\n\n  public detectFileReferences(packet: any, rawData: Buffer): FileReference[] {\n    const detectedFiles: FileReference[] = [];\n    const payloadString = rawData.toString('utf-8'); // Expensive for large packets?\n\n    // HTTP\n    if (packet.protocol === 'HTTP' && payloadString.startsWith('HTTP/')) {\n      const headers = this.parseHttpHeaders(payloadString);\n      const contentType = headers['content-type'];\n      const contentDisposition = headers['content-disposition'];\n      const contentLength = parseInt(headers['content-length'] || '0', 10);\n\n      let filename: string | undefined;\n\n      if (contentDisposition) {\n        const filenameMatch = /filename\\*?=['\"]?(?:UTF-8''|)([^;\"]+)['\"]?/.exec(\n          contentDisposition,\n        );\n        if (filenameMatch && filenameMatch[1]) {\n          filename = decodeURIComponent(filenameMatch[1]);\n        }\n      }\n\n      if (!filename && contentType) {\n        filename = `unknown_file.${contentType.split('/')[1] || 'bin'}`;\n      }\n\n      const isFileContentType =\n        contentType &&\n        FileExtractor.HTTP_FILE_CONTENT_TYPES.some((regex) =>\n          regex.test(contentType),\n        );\n\n      if (filename && isFileContentType && contentLength > 0) {\n        const headerEndIndex = rawData.indexOf('\\r\\n\\r\\n');\n        if (headerEndIndex !== -1) {\n          // We found a file!\n          // We verify size matches logic?\n          detectedFiles.push({\n            id: uuidv4(),\n            filename: filename,\n            size: contentLength,\n            mimeType: contentType || 'application/octet-stream',\n            sourcePacketId: String(packet.id),\n            dataOffset: headerEndIndex + 4,\n          });\n        }\n      }\n    }\n\n    // FTP\n    if (\n      packet.protocol === 'FTP' ||\n      packet.destPort === 21 ||\n      packet.sourcePort === 21\n    ) {\n      const key = this.getControlKey(packet);\n      if (key) {\n        // Check PORT\n        const portMatch = payloadString.match(\n          /PORT\\s+(\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)/,\n        );\n        if (portMatch) {\n          const p1 = parseInt(portMatch[5], 10);\n          const p2 = parseInt(portMatch[6], 10);\n          const port = p1 * 256 + p2;\n          this.ftpControlToDataPort.set(key, port);\n        }\n\n        // PASV\n        const pasvMatch = payloadString.match(\n          /227.*\\((\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)\\)/,\n        );\n        if (pasvMatch) {\n          const p1 = parseInt(pasvMatch[5], 10);\n          const p2 = parseInt(pasvMatch[6], 10);\n          const port = p1 * 256 + p2;\n          this.ftpControlToDataPort.set(key, port);\n        }\n\n        // STOR/RETR\n        const ftpCommandMatch = payloadString.match(/(STOR|RETR)\\s+([^\\r\\n]+)/);\n        if (ftpCommandMatch) {\n          const command = ftpCommandMatch[1] as 'STOR' | 'RETR';\n          const filename = ftpCommandMatch[2].trim();\n          const dataPort = this.ftpControlToDataPort.get(key);\n\n          detectedFiles.push({\n            id: uuidv4(),\n            filename,\n            size: 0,\n            mimeType: 'application/octet-stream',\n            sourcePacketId: String(packet.id),\n            ftpDataPort: dataPort,\n            ftpTransferType: command,\n          });\n        }\n      }\n    }\n\n    return detectedFiles;\n  }\n}\n\nexport const fileExtractor = new FileExtractor();\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/utils/stringExtractor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FILE_PATH_REGEX' is assigned a value but never used.","line":20,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { v4 as uuidv4 } from 'uuid';\n\nexport interface ExtractedString {\n  id: string;\n  type: 'IP' | 'URL' | 'Email' | 'Credential' | 'FilePath' | 'Other';\n  value: string;\n  packetId: string;\n  payloadOffset: number;\n  length: number;\n}\n\n// Regex patterns (Same as client)\nconst IPV4_REGEX =\n  /\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/g;\n// const IPV6_REGEX = /\\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\\b/g; // Simplified for now, often matches random hex\nconst URL_REGEX = /(?:https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*/gi;\nconst EMAIL_REGEX = /\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b/gi;\nconst CREDENTIAL_REGEX =\n  /\\b(?:user(?:name)?|pass(?:word)?|api_key|token|auth|bearer|secret)(?:[=\\s:]+)?['\"]?([A-Z0-9._%+-]+)['\"]?\\b/gi;\nconst FILE_PATH_REGEX =\n  /(?:[a-zA-Z]:\\\\(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]+)|(?:(?:\\/[^/ ]*)+\\/?)/g;\n\nconst MIN_PRINTABLE_STRING_LENGTH = 4;\n\nexport function extractStringsFromBuffer(\n  payload: Buffer,\n  packetId: string,\n  payloadOffset: number = 0,\n): ExtractedString[] {\n  const extracted: ExtractedString[] = [];\n  // Convert buffer to string, replacing non-printable/invalid chars might be safer for regex\n  // But 'utf-8' decode is standard\n  const payloadString = payload.toString('utf-8');\n\n  const addExtracted = (\n    type: ExtractedString['type'],\n    value: string,\n    index: number,\n    length: number,\n  ) => {\n    if (\n      !extracted.some(\n        (e) => e.value === value && e.payloadOffset === payloadOffset + index,\n      )\n    ) {\n      extracted.push({\n        id: uuidv4(),\n        type,\n        value,\n        packetId,\n        payloadOffset: payloadOffset + index,\n        length,\n      });\n    }\n  };\n\n  // 1. Regex-based\n  const extractWithRegex = (regex: RegExp, type: ExtractedString['type']) => {\n    regex.lastIndex = 0;\n    let match;\n    while ((match = regex.exec(payloadString)) !== null) {\n      const valueToExtract =\n        type === 'Credential' && match[1] ? match[1] : match[0];\n      const index =\n        type === 'Credential' && match[1]\n          ? match.index + match[0].indexOf(match[1])\n          : match.index;\n\n      if (\n        valueToExtract &&\n        valueToExtract.length >= MIN_PRINTABLE_STRING_LENGTH\n      ) {\n        addExtracted(type, valueToExtract, index, valueToExtract.length);\n      }\n    }\n  };\n\n  extractWithRegex(IPV4_REGEX, 'IP');\n  extractWithRegex(URL_REGEX, 'URL');\n  extractWithRegex(EMAIL_REGEX, 'Email');\n  extractWithRegex(CREDENTIAL_REGEX, 'Credential');\n  // extractWithRegex(FILE_PATH_REGEX, 'FilePath'); // Too noisy usually, enable if needed\n\n  // 2. Printable Strings\n  // Basic loop for printable chars\n  let currentString = '';\n  let startIndex = -1;\n\n  for (let i = 0; i < payload.length; i++) {\n    const byte = payload[i];\n    if (byte >= 0x20 && byte <= 0x7e) {\n      if (startIndex === -1) startIndex = i;\n      currentString += String.fromCharCode(byte);\n    } else {\n      if (currentString.length >= MIN_PRINTABLE_STRING_LENGTH) {\n        // Optimization: Don't add if we already found it via regex logic?\n        // Or just add as 'Other'\n        addExtracted('Other', currentString, startIndex, currentString.length);\n      }\n      currentString = '';\n      startIndex = -1;\n    }\n  }\n  if (currentString.length >= MIN_PRINTABLE_STRING_LENGTH) {\n    addExtracted('Other', currentString, startIndex, currentString.length);\n  }\n\n  return extracted;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/utils/threatDetection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/workers/pcap.worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/delphijc/Projects/net-pack-parser/server/src/workers/pcapWorkerManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerPath' is assigned a value but never used.","line":19,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { kafkaService } from '../services/kafkaService';\nimport { Worker } from 'worker_threads';\nimport path from 'path';\nimport { activeSessions } from '../routes/analysis';\n\nexport const startPcapWorker = async () => {\n  console.log('Starting PCAP Worker...');\n\n  // Subscribe to PCAP upload topic\n  await kafkaService.subscribe('pcap-upload', async (payload) => {\n    if (!payload.message.value) return;\n\n    const event = JSON.parse(payload.message.value.toString());\n    const { filePath, sessionId } = event;\n\n    console.log(`Worker received task: Parse ${sessionId}`);\n\n    // Use Worker Thread to prevent event loop blocking\n    const workerPath = path.join(__dirname, './workers/pcap.worker.js');\n\n    // Note: In dev TS environment, we might need to point to the .ts file via ts-node or similar if not built.\n    // But Docker runs 'npm run build' so it runs JS.\n    // However, path.join(__dirname, './workers/pcap.worker.js') would be:\n    // dist/workers/workers/pcap.worker.js? No.\n    // __dirname in dist/workers/pcapWorker.js is .../dist/workers.\n    // So ./pcap.worker.js is correct if both are in same folder.\n    // checking where pcap.worker.ts will be output: dist/workers/pcap.worker.js.\n    // So path.join(__dirname, 'pcap.worker.js') is correct.\n\n    const worker = new Worker(path.join(__dirname, 'pcap.worker.js'), {\n      workerData: { filePath, sessionId },\n    });\n\n    worker.on('message', (msg) => {\n      if (msg.type === 'progress') {\n        if (activeSessions[msg.sessionId]) {\n          activeSessions[msg.sessionId].progress = msg.count;\n          activeSessions[msg.sessionId].summary.packetCount = msg.count;\n        }\n      } else if (msg.type === 'complete') {\n        console.log(`Worker finished task: Parse ${msg.sessionId}`);\n        if (activeSessions[msg.sessionId]) {\n          activeSessions[msg.sessionId].status = 'complete';\n        }\n      } else if (msg.type === 'error') {\n        console.error(\n          `Worker failed task ${msg.sessionId || 'unknown'}:`,\n          msg.error,\n        );\n        if (msg.sessionId && activeSessions[msg.sessionId]) {\n          activeSessions[msg.sessionId].error = msg.error;\n          activeSessions[msg.sessionId].status = 'error';\n        }\n      }\n    });\n\n    worker.on('error', (err) => {\n      console.error('Worker thread error:', err);\n    });\n\n    worker.on('exit', (code) => {\n      if (code !== 0) {\n        console.error(`Worker stopped with exit code ${code}`);\n      }\n    });\n  });\n};\n","usedDeprecatedRules":[]}]
